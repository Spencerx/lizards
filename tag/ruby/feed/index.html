<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>openSUSE Lizards &#187; Ruby</title>
	<atom:link href="http://lizards.opensuse.org/tag/ruby/feed/" rel="self" type="application/rss+xml" />
	<link>http://lizards.opensuse.org</link>
	<description>Blogs and Ramblings of the openSUSE Members</description>
	<lastBuildDate>Mon, 24 Mar 2014 12:46:00 +0000</lastBuildDate>
	<language>en-US</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.8.1</generator>
	<item>
		<title>wxRuby is now on BuildService</title>
		<link>http://lizards.opensuse.org/2013/03/22/wxruby-is-now-on-buildservice/</link>
		<comments>http://lizards.opensuse.org/2013/03/22/wxruby-is-now-on-buildservice/#comments</comments>
		<pubDate>Fri, 22 Mar 2013 09:29:12 +0000</pubDate>
		<dc:creator><![CDATA[FabioMux]]></dc:creator>
				<category><![CDATA[Build Service]]></category>
		<category><![CDATA[Packaging]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[gems]]></category>
		<category><![CDATA[Ruby]]></category>
		<category><![CDATA[wxRuby]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=9331</guid>
		<description><![CDATA[I am happy to announce that i succeded in compiling wxRuby 2.0.1 on my Buildservice account and it is available to be installed in just one click for openSUSE 12.2 and 12.3. wxRuby is an old but working library based on wxWidgets toolkit, till some day ago the dependency from SWIG 1.3.38 and some small [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>I am happy to announce that i succeded in compiling wxRuby 2.0.1 on my Buildservice account and it is available to be installed in just one click for openSUSE 12.2 and 12.3.</p>
<p>wxRuby is an old but working library based on wxWidgets toolkit, till some day ago the dependency from SWIG 1.3.38 and some small errors raised during the manual compilation, made the use of this library the worst nightmare for beginners who was looking for a fast approach to GUI based programming in Ruby.</p>
<p>After some day spent to investigate about a possible upgrade of the SWIG dependency to the current 2.0 version, i produced some patches to fix this and the other annoying compiling errors, and finally, thanks to the Buildservice infrastructure, a wxRuby RPM compiled from sources with the relative patches are now availables for all openSUSE users!</p>
<p>As far i googled this should be the first distro to have a precompiled and working wxruby gem among its repositories (being compiled from sources the gem is generated for 32 and 64 bits architecture from Buildservice itself), so Rubyists take a look on software.opensuse.org, select the package coming from my home project account and enjoy!</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2013/03/22/wxruby-is-now-on-buildservice/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>YaST++: next step in system management</title>
		<link>http://lizards.opensuse.org/2012/02/15/yast-next-step-in-system-management/</link>
		<comments>http://lizards.opensuse.org/2012/02/15/yast-next-step-in-system-management/#comments</comments>
		<pubDate>Wed, 15 Feb 2012 10:07:46 +0000</pubDate>
		<dc:creator><![CDATA[Jiří Suchomel]]></dc:creator>
				<category><![CDATA[Systems Management]]></category>
		<category><![CDATA[YaST]]></category>
		<category><![CDATA[Ruby]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=8523</guid>
		<description><![CDATA[All of you probably know YaST, the installation and system configuration tool for openSUSE. With current YaST, plenty of tasks that system administrator could image are doable using understandable UI: creating users, bootloader configuration, network setup and even Apache configuration. However, it has its drabacks. While being do-it-all tool, it comes with large package dependency [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>All of you probably know <a title="YaST" href="http://en.opensuse.org/Portal:YaST">YaST</a>, the installation and system configuration tool for openSUSE.</p>
<p>With current YaST, plenty of tasks that system administrator could image are doable using understandable UI: creating users, bootloader configuration, network setup and even Apache configuration. However, it has its drabacks. While being do-it-all tool, it comes with large package dependency even for only simple tasks. It is largely written in an outdated language which has its roots in last century and only few people in the world know it. It lacks the testing abilities of modern languages. It is SUSE specific and lacks larger developer community.</p>
<p>So last year, we (actually, <a href="http://lizards.opensuse.org/author/jreidinger/">Josef</a>) came with the idea for YaST++: new configuration library that could be a common layer for configuration tools in SUSE (and beyond). Such library should provide simple and understandable API for all tools around. Written in up-to-date language many people know and like, so they can join the development (spoiler: we chose Ruby). Offering bindings  to various other languages, so different tools could benefit from it,</p>
<p>Now, this &#8220;YaST++&#8221; does not actually mean to be replacement of current YaST (with its Qt/GTK/ncurses UI), but it could replace the lower layer of YaST, which is doing the real system configuration. And it would be open for other library users as well: the obvious targets for now are <a href="http://en.opensuse.org/Portal:WebYaST">WebYaST</a> and <a href="http://en.opensuse.org/Portal:SUSE_Studio">SUSE Studio</a>, but we&#8217;d like to see if other tools are interested: even from non-SUSE world.</p>
<p>From architecture point, YaST++ is itself divided into two layers, we call them YLib and config agents. YLib is the high-level library, providing the API (like &#8216;create user&#8217;, &#8216;set new time zone&#8217; etc.). Config agents form the lower layer, that is actually touching the system. This low level consits of D-BUS services, which are running as a root (thus have the full access to the system) but are started only for users with proper permissions (we are using polkit for policies definition). So YaST++ offers role based access management, where specific users can be allowed to do specific sets of actions. For more, check our <a title="Architecture document" href="https://github.com/yast/yast--/blob/master/doc/architecture.txt">architecture document</a> (still WIP).</p>
<p>We&#8217;ve started to work on several modules (none of them is finished, though). Let&#8217;s look at example in module for users configuration (packages yast++lib-users and config_agent-passwd). Look at example code in &#8216;users_read&#8217; script of <a href="https://github.com/yast/yast--/tree/master/yast++lib-users/examples">examples</a> subdirectory. With simple ruby call of</p>
<blockquote><p>YLib::Users::read({})</p></blockquote>
<p>you get the list of current users. If the script gets additional parameters, it can list e.g. all data about selected user, or only specific information about all:</p>
<blockquote><p>&gt; ./users_read root<br />
{&#8220;gid&#8221;=&gt;&#8221;0&#8243;, &#8220;name&#8221;=&gt;&#8221;root&#8221;, &#8220;uid&#8221;=&gt;&#8221;0&#8243;, &#8220;shell&#8221;=&gt;&#8221;/bin/bash&#8221;, &#8220;password&#8221;=&gt;&#8221;x&#8221;, &#8220;home&#8221;=&gt;&#8221;/root&#8221;}</p>
<p>&gt; ./users_read only name<br />
{&#8220;result&#8221;=&gt;["Batch jobs daemon", "User for Avahi", "bin", "Daemon", "dnsmasq", "FTP account", "Games account", "User for haldaemon", "User for OpenLDAP", "LightDM daemon", "Printing daemon", "Mailer daemon", "Manual pages viewer", "User for D-Bus", "MySQL database admin", "News system", "user for nginx", "nobody", "NTP daemon", "User for build service backend", "openslp daemon", "PolicyKit", "Postfix Daemon", "PulseAudio daemon", "qemu user", "Router ADVertisement Daemon for", "root", "RealtimeKit", "Smart Card Reader", "user for smolt", "SSH daemon", "NFS statd daemon", "Novell Customer Center User", "TFTP account", "usbmuxd daemon", "Unix-to-Unix CoPy system", "WWW daemon apache", "User for YaST-Webservice", "LXDE Display Manager daemon"]}</p></blockquote>
<p>YaST++ developement is in its early stage (even the name is not final), but we already have something to offer.</p>
<p>Check the code and documentation at <a href="https://github.com/yast/yast--">github project</a>. There&#8217;s already a simple <a href="https://github.com/yast/yast--/wiki/Tutorial">tutorial</a> for those who want to try writing new parts.</p>
<p>Download packages from <a href="https://build.opensuse.org/project/show?project=YaST%3AHead%3AYaST%2B%2B">Build Service project</a>.</p>
<p>Comment/propose/oppose in public <a href="http://lists.opensuse.org/yast-devel/">YaST mailing list</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2012/02/15/yast-next-step-in-system-management/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
		</item>
		<item>
		<title>Temporary overwrite method for specific task</title>
		<link>http://lizards.opensuse.org/2011/03/18/temporary-overwrite-method-for-specific-task/</link>
		<comments>http://lizards.opensuse.org/2011/03/18/temporary-overwrite-method-for-specific-task/#comments</comments>
		<pubDate>Fri, 18 Mar 2011 12:37:01 +0000</pubDate>
		<dc:creator><![CDATA[Josef Reidinger]]></dc:creator>
				<category><![CDATA[Miscellaneous]]></category>
		<category><![CDATA[Rails]]></category>
		<category><![CDATA[Ruby]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=6810</guid>
		<description><![CDATA[Hi, today I must solve issue with not well structured code. Problem is that one method return last correct version, but in one specific case it needs to return newest version (even incorrect). There is many calls between top level method which know what needs to call and target method which is called from generic [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Hi,<br />
today I must solve issue with not well structured code. Problem is that one method return last correct version, but in one specific case it needs to return newest version (even incorrect). There is many calls between top level method which know what needs to call and target method which is called from generic code. Now I need to fix it and code is not well tested and quite sensitive to changes ( this fix is fix of another fix :). So what is the safest way to change it?<br />
I decide that the best solution which doesn&#8217;t change almost nothing ( but is suitable just for maintenance update, for trunk I create better solution ) is temporary overwrite of target method to change its behavior. Now how to do it?<br />
There is simple example:</p>
<pre>
class T
  def test
    puts "test"
  end

  def lest
    puts "lest"
  end

  def m
    test
  end
end


T.new.m
T.send(:define_method,:m_a) { lest }
T.send(:alias_method, :m_old, :m)
T.send(:alias_method, :m, :m_a)
T.new.m
T.send(:alias_method, :m, :m_old)
T.send(:undef_method, :m_a)
T.send(:undef_method, :m_old)
T.new.m
</pre>
<p>as you can see after modification class is exact same as before ( except if there is method a, but it is possible to handle it via introspection and dynamic choose of method). I don&#8217;t need to change whole stack of calls to add parameter or introduce new singleton class which can have flag.<br />
I hope it help someone with his fix of not so well written piece of software.</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2011/03/18/temporary-overwrite-method-for-specific-task/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>Easy scripting actions with susestudio alias new rubygem studio_api</title>
		<link>http://lizards.opensuse.org/2010/12/23/rubygem-studio_api/</link>
		<comments>http://lizards.opensuse.org/2010/12/23/rubygem-studio_api/#comments</comments>
		<pubDate>Thu, 23 Dec 2010 17:37:45 +0000</pubDate>
		<dc:creator><![CDATA[Josef Reidinger]]></dc:creator>
				<category><![CDATA[Miscellaneous]]></category>
		<category><![CDATA[Ruby]]></category>
		<category><![CDATA[studio api]]></category>
		<category><![CDATA[susestudio]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=6208</guid>
		<description><![CDATA[Hi, Now I work for SLMS ( Suse Lifecycle Management Server ) project. It cooperate with SuSE studio and use its API. I get idea that more people could benefit from easy access to studio API from ruby so I extract functionality and improve behavior, documentation and testing and now there is new rubygem studio_api. [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Hi,<br />
Now I work for SLMS ( Suse Lifecycle Management Server ) project. It cooperate with SuSE studio and use its API. I get idea that more people could benefit from easy access to studio API from ruby so I extract functionality and improve behavior, documentation and testing and now there is new rubygem studio_api.<br />
Why you should use this gem?</p>
<ul>
<li> ActiveResource Behavior</li>
<li> Actively maintained ( and will be due to SLMS support )</li>
<li> Tightly developed with guys from studio team</li>
<li> Well documented with yard</li>
<li> Good test coverage</li>
</ul>
<p><span id="more-6208"></span><br />
I think then a lot of glory words is better to show example. It is example based on example from documentation.<br />
Example goal is simple. Create new appliance in studio, add own cool rpm and build appliance with it. It can be useful to test your new version of software in stable environment and have automatic appliance in which you can test it.</p>
<pre>
  require 'rubygems'
  require 'studio_api'

  # Fill up Studio credentials (user name, API key, API URL)
  # See https://susestudio.com/user/show_api_key if you are using SUSE Studio online
  connection = StudioApi::Connection.new('user', 'pwd', 'https://susestudio.com/api/v1/user')
  # Setup the connection for all ActiveResource based class
  StudioApi::Util.configure_studio_connection connection

  # Find template with KDE4 for SLE11SP1
  templates = StudioApi::TemplateSet.find(:all).find {|s| s.name == "default" }.template
  template = templates.find { |t| t.name == "SLED 11 SP1, KDE 4 desktop" }
  # clone template to new appliance
  appliance = StudioApi::Appliance.clone template.appliance_id, :name =&gt; "New cool appliance", :arch =&gt; "i686"
  puts "Created appliance #{appliance.inspect}"

  #add own rpm built agains SLED11_SP1
  File.open("/home/jreidinger/rpms/cool_rpm-1.0-1.60.noarch.rpm","r") do |f|
    StudioApi::Rpm.upload f, "SLED11_SP1"
  end
  # and choose it in appliance ( and of course add repository with own rpms)
  appliance.add_user_repository
  appliance.add_package "cool_rpm", :version =&gt; "1.0-1.60"
  #check if appliance is OK, like dependency problems with new rpm
  if appliance.status.state != "ok"
    raise "appliance is not OK - #{appliance.status.issues.inspect}"
  end
  
  build = StudioApi::RunningBuild.new(:appliance_id =&gt; appliance.id, :image_type =&gt; "xen")
  build.save
  build.reload
  while build.state != "finished"
    puts "building (#{build.state}) - #{build.percent}%"
    sleep 5
    build.reload
  end

  final_build = StudioApi::Build.find build.id
  puts "Appliance to download: #{final_build.download_url}"
</pre>
<p>So I hope that you like interface how I design it. Of course I welcome any suggestion how to improve it. You can use comments here, novell bugzilla or issues on github.<br />
How to install it:</p>
<ul>
<li> In opensuse: <a href="http://software.opensuse.org/ymp/devel:languages:ruby:extensions/openSUSE_11.3/rubygem-studio_api.ymp?base=openSUSE%3A11.3&amp;query=rubygem-studio_api">1-click for 11.3</a> and <a href="http://software.opensuse.org/ymp/devel:languages:ruby:extensions/openSUSE_Factory/rubygem-studio_api.ymp?base=openSUSE%3AFactory&amp;query=rubygem-studio_api">1-click for factory</a></li>
<li> alternative possible everywhere is to use<br />
<code>gem install studio_api</code>
</li>
</ul>
<p>At the end few useful links if you are interested:<br />
<a href="https://github.com/jreidinger/studio_api">repository on github</a><br />
<a href="http://rdoc.info/github/jreidinger/studio_api/master/frames">yard documentation</a><br />
<a href="http://rubygems.org/gems/studio_api">gem at rubygems.org</a></p>
<p>Thanks for attention and I welcome any comments</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2010/12/23/rubygem-studio_api/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Recompiling wxRuby</title>
		<link>http://lizards.opensuse.org/2010/09/04/recompiling-wxruby/</link>
		<comments>http://lizards.opensuse.org/2010/09/04/recompiling-wxruby/#comments</comments>
		<pubDate>Sat, 04 Sep 2010 12:55:35 +0000</pubDate>
		<dc:creator><![CDATA[FabioMux]]></dc:creator>
				<category><![CDATA[Education]]></category>
		<category><![CDATA[Miscellaneous]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[Ruby]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=4532</guid>
		<description><![CDATA[Who uses Ruby might be interested to try this interesting multiplatform library that allows the development of GUI (Graphic User Interface) with a considerable visual impact and compatible with the three most popular Operating Systems: Linux (via GTK) Windows (with Native controls) and OSX (via Aqua). (This article is also available for italian users) Usually [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Who uses Ruby might be interested to try this interesting multiplatform library that allows the development of GUI (Graphic User Interface) with a considerable visual impact and compatible with the three most popular Operating Systems: Linux (via GTK) Windows (with Native controls) and OSX (via Aqua). (<a href="http://italiafreeware.byethost4.com/?q=node/145">This article is also available for italian users</a>)<br />
<span id="more-4532"></span></p>
<p>Usually need install the wxGTK libraries and the gem wxruby (or wxruby-ruby19 if using ruby 1.9) and start creating your own scripts.</p>
<p><code>$ sudo zypper in wxGTK wxGTK-gl<br />
$ sudo gem install wxruby</code></p>
<p>But sometimes we could find an Error for a wrong compatibilty between the installed version of the wxGTK libraries and the wrapper library included in the gem.</p>
<p><code>/usr/lib/ruby/gems/1.8/gems/wxruby-2.0.1-x86-linux/lib/wxruby2.so:<br />
symbol _ZN13wxAuiNotebook14ShowWindowMenuEv, version WXU_2.8.5 not defined in file libwx_gtk2u_aui-2.8.so.0 with link time reference -<br />
/usr/lib/ruby/gems/1.8/gems/wxruby-2.0.1-x86-linux/lib/wxruby2.so</code></p>
<p>When an error like this appear, the unique solution is recompile the gem.</p>
<p>What we need:</p>
<ul>
<li><strong>rubygems</strong>: Tool for manage the ruby&#8217;s gems;</li>
<li><strong>rake</strong>: the Ruby&#8217;s version of the popular <strong>make</strong>, will help us to compile wxRuby;</li>
<li><strong>wxGTK, wxGTK-gl, wxGTK-devel</strong>: Library and headers needed for run our scripts and produce the object&#8217;s file;</li>
<li><strong>SWIG</strong>: Build the wrapper classes in Ruby from the C++ sources, wxRuby 2.0.1 need the version 1.3.8;</li>
<li><strong>gcc-c++</strong>: The C++ compiler used for build the wrapper library;</li>
<li><strong>wxRuby</strong>: We have to download the source&#8217;s package directly from Rubyforge.</li>
</ul>
<p>Added the repository which contains the Ruby extensions (warning to the portion of the address that refers the version of openSUSE), we can proceed with the installation confirming the request of the dependent packages:</p>
<p><code>$ sudo zypper ar http://download.opensuse.org/repositories/devel:/languages:/ruby:/extensions/openSUSE_11.3/ RubyExtensions<br />
$ sudo zypper ref<br />
$ sudo zypper install rubygems rubygem-rake gcc-c++ wxGTK-devel rubygem-ffi-swig-generator make</code></p>
<p>It&#8217;s time to download the <a href="http://sourceforge.net/projects/swig/files/swig/swig-1.3.38/swig-1.3.38.tar.gz/download">sources of SWIG version 1.3.38</a> from sourceforge, then uncompress and install it:</p>
<p><code>tar -xvf swig-1.3.38.tar.gz<br />
cd swig-1.3.38<br />
./configure &amp;&amp; make<br />
sudo make install</code></p>
<p>All the packages are ready, we have to set some environment variables before continue:</p>
<p><code>export SWIG_CMD=/usr/local/bin/swig<br />
export WXRUBY_EXCLUDED=GLCanvas<br />
export WXRUBY_VERSION=2.0.1</code></p>
<p>The second instruction is important for ignore all the references to the openGL library, which are not availables in unicode version.</p>
<p>The next step is download the <a href="http://rubyforge.org/frs/?group_id=35">wxRuby&#8217;s source</a> from Rubyforge and start to compile</p>
<p><code>tar -xvf wxruby-2.0.1.tar.gz<br />
cd wxruby-2.0.1<br />
rake</code></p>
<p>After this procedure end you can remove the old gem and build &amp; install the new:</p>
<p><code>rake gem<br />
sudo gem install wxruby-2.0.1-x86-linux.gem</code></p>
<p>Personally, I needed recompile wxRuby in openSUSE 11.2; with the new version (11.3) standard packages work fine, anyway i wished share my experience for someone could meet the same trouble in the future :))</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2010/09/04/recompiling-wxruby/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
