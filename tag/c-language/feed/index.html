<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>openSUSE Lizards &#187; C-Language</title>
	<atom:link href="http://lizards.opensuse.org/tag/c-language/feed/" rel="self" type="application/rss+xml" />
	<link>http://lizards.opensuse.org</link>
	<description>Blogs and Ramblings of the openSUSE Members</description>
	<lastBuildDate>Mon, 24 Mar 2014 12:46:00 +0000</lastBuildDate>
	<language>en-US</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.8.1</generator>
	<item>
		<title>openSUSE and GCC part 10: Distributing to other distributions than openSUSE with OBS</title>
		<link>http://lizards.opensuse.org/2014/01/07/opensuse-and-gcc-part-10/</link>
		<comments>http://lizards.opensuse.org/2014/01/07/opensuse-and-gcc-part-10/#comments</comments>
		<pubDate>Tue, 07 Jan 2014 08:15:54 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Packaging]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[C-Language]]></category>
		<category><![CDATA[obs]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10387</guid>
		<description><![CDATA[Last time I talked about OBS and how to compile your application that you have developed with GCC. OBS is much more than just a tool for compiling openSUSE additional packages. You can also compile Debian, Ubuntu, Arch and Fedora (and couple more) but why on earth you want to do that? Short answer: because [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><a href="//lizards.opensuse.org/2013/12/11/opensuse-and-gcc-part-9/" title="openSUSE and GCC part 9: Open Build Service why should I use it?">Last time I talked about OBS</a> and how to compile your application that you have developed with GCC. <a href="http://openbuildservice.org/" title="Open Build Service">OBS</a> is much more than just a tool for compiling openSUSE additional packages. You can also compile <a href="http://debian.org" title="Debian ">Debian</a>, <a href="http://www.ubuntu.com/" title="Ubuntu linux">Ubuntu</a>, <a href="https://www.archlinux.org/" title="Arch Linux">Arch</a> and <a href="http://fedoraproject.org/" title="Fedora project">Fedora</a> (and couple more) but why on earth you want to do that? Short answer: because you can! Little bit longer answer: because you can and freedom is two way road. You can&#8217;t guess what Linux distribution or OS your user wants to use but you can make sure that you application is first class citizen in that Linux distribution.<span id="more-10387"></span> Of course You can use Fedora build service or Ubuntu launchpad but they are just for that distribution only. If it&#8217;s fine with you. Be happy and use these marvelous services. If you have woken up in night all sweat. Thinking all these openSUSE lizards that are unhappy because they can&#8217;t use your fabulous application.. it&#8217;s time to start sleeping well.</p>
<h2>Fedora distribution or RHEL</h2>
<p>RPM based Linux distributions are very easy with OBS. You just have to make SPEC file generic. If you like to do it right you should read <a href="http://en.opensuse.org/openSUSE:Build_Service_cross_distribution_howto" title="openSUSE:Build Service cross distribution howto">openSUSE:Build Service cross distribution howto</a> and learn how to do it.</p>
<h2>OBS and DEB based distributions</h2>
<p>This is little bit trickier but not much. You needed decent DSC-file (Most dsc files goes without changes. If you like to use Bzip2 file then you need to add &#8216;DEBTRANSFORM-TAR&#8217; in dsc-file) file and then you need &#8216;debian.tar.gz&#8217; in your project or &#8216;debian/&#8217;-dir in your project. What are files that you need in you debian package/dir? That is a very good question and it stays unanswered here because it&#8217;s not point of this blog. If you are curious enough you can always download &#8216;debian.tar.gz&#8217; from <a href="https://build.opensuse.org/package/show/home:illuusio:example/sdl_displaybitmap" title="OBS Example application">example application</a> and study files or look <a href="https://wiki.debian.org/HowToPackageForDebian" title="HowToPackageForDebian">Debian documentation</a> about it.</p>
<h2>Arch</h2>
<p>Arch is most unknown distribution for me but it has vibrant community and active development so providing packages to them is good thing. They seems to like live bleeding edge. So Just add Arch distribution in your project in OBS and then fill PKGBUILD-file with necessary lines and like magic you have Arch supported (<a href="https://build.opensuse.org/package/show/home:illuusio:example/sdl_displaybitmap" title="PKGBUILD">Look at example PKGBUILD-file if you don&#8217;t understand a thing</a>).</p>
<p>This was it! No more articles about GCC or around it. Next I&#8217;ve going to dive low level Linux Multimedia especially in audio and FFmpeg (and how you do them in openSUSE). <a href="//lizards.opensuse.org/author/illuusio/" title="Blog">if you haven&#8217;t read rest of articles and you feel you missed something</a>. Go on a read them and if you missed good <a href="http://smithfarm-thebrain.blogspot.fi/2013/08/opensuse-packaging-workflow.html" title="OBS client OSC">OSC-blog you can read it too</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2014/01/07/opensuse-and-gcc-part-10/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>openSUSE and GCC part 8: RPMs and how to write them</title>
		<link>http://lizards.opensuse.org/2013/12/03/opensuse-and-gcc-part-8-rpms-and-how-to-write-them/</link>
		<comments>http://lizards.opensuse.org/2013/12/03/opensuse-and-gcc-part-8-rpms-and-how-to-write-them/#comments</comments>
		<pubDate>Tue, 03 Dec 2013 09:30:00 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[C-Language]]></category>
		<category><![CDATA[rpm]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10208</guid>
		<description><![CDATA[It seems this it&#8217;s already 8 of this 10 part series of using GCC with openSUSE. This time topic is: RPM. RPM started as Redhat Package Manager and then it involved to RPM package manager (self explaining acronym like GNU). RPM packages are just files containing all the needed stuff to install application, font or [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>It seems this it&#8217;s already 8 of this 10 part series of using GCC with openSUSE. This time topic is: RPM. RPM started as <a href="http://en.wikipedia.org/wiki/RPM_Package_Manager" title="Rpm Package Manager">Redhat Package Manager</a> and then it involved to RPM package manager (self explaining acronym like GNU). RPM packages are just files containing all the needed stuff to install application, font or something else in to openSUSE system.<span id="more-10208"></span><br />
RPM is currently wide adopted in Linux distributions openSUSE, embedded Yocto, Fedora and Madriva for name few. Although Yocto can use Debian packages also as base. I have been using an <a href="//lizards.opensuse.org/2013/10/22/opensuse-and-gcc-part-3/" title="openSUSE and GCC part 3: RPM devel packages">example</a> program to <a href="//lizards.opensuse.org/2013/10/28/opensuse-and-gcc-part4/" title="openSUSE and GCC part 4: Pkg-config and what one can do with it">show how to develop</a> very easy application with openSUSE and GCC. Currently <a href="//lizards.opensuse.org/2013/11/19/opensuse-and-gcc-part-7/" title="openSUSE and GCC part 7: autotools and how I do it">it uses Autotools tools</a>. Take my advise your application is not worth of anything if you can&#8217;t delivery it to users. Most of the applications (especially closed source) under Linux are distributed as tar-ball format. RPM is not about having Windows style setup it&#8217;s about knowing what is installed in you system.</p>
<h2>RPM agnostics</h2>
<p>There is actually two kinds of RPMs. Binary RPM and then there is Source RPM. Source RPM contains everything needed to compile this package again. Source rpm ending is &#8216;.src.rpm&#8217; or &#8216;nosrc.rpm&#8217;. Binary RPM is architecture specific. So if you have &#8216;arm7v.rpm&#8217; it wont run your x86_64 or x86 machine because it&#8217;s ARM7 binary code. There is also noarch.rpm that is architectural non specific.<br />
In openSUSE traditionally if you build RPM it goes to &#8216;/usr/src/packages&#8217; directory and there is sub directories</p>
<pre>
BUILD/ - Building is done here
SOURCES/ - Contains needed sources for building including patches
SRPMS/ - Where Source RPMS are placed after build
BUILDROOT/ - This is ROOT place where make install places installed files (because you don't want them to go real root dir) 
RPMS/ - All the RPMs are placed here (It contains i686, x86_64 and noarch subdirs where those arch files are placed)
SPECS/ - Where .spec files are placed
</pre>
<p>So if you build i686 RPM with your x86 openSUSE then it would go to &#8216;/usr/src/packages/RPMS/i686&#8242; directory and Source RPM &#8216;/usr/src/packages/SRPMS&#8217; directory.</p>
<h2>Example</h2>
<p>Now you should <a href="//lizards.opensuse.org/2013/11/19/opensuse-and-gcc-part-7/" title="openSUSE and GCC part 7: autotools and how I do it">read Part 7</a> and <a href="//lizards.opensuse.org/2013/11/12/opensuse-and-gcc-part-6/" title="openSUSE and GCC part 6: Introduction to autotools">part 6</a> of this series to have example application and autotools installed. then we install rpm-build</p>
<pre>
zypper install rpm-build
</pre>
<p>and make distribution tar-ball of sdl_displaybitmap with</p>
<pre>
make dist
</pre>
<p>there should be  &#8216;sdl_displaybitmap-1.0.tar.bz2&#8242; file now in same directory. then copy this SPEC file to file named &#8216;sdl_displaybitmap.spec&#8217; in same directory you have &#8216;sdl_displaybitmap-1.0.tar.bz2&#8242;</p>
<pre>
Name:           sdl_displaybitmap
Version:        1.0
Release:        1%{?dist}
Summary:        Some SDL Sample

Group:          Amusements/Toys/Other
License:        SUSE-Public-Domain
URL:            http://content.gpwiki.org/index.php/SDL:Tutorials:Displaying_a_Bitmap
Source0:        sdl_displaybitmap-1.0.tar.bz2
BuildRoot:      %{_tmppath}/%{name}-%{version}-build

BuildRequires:  gcc
BuildRequires:  SDL_image-devel
BuildRequires:  libtool
BuildRequires:  automake
BuildRequires:  autoconf

%description
Small example how to use SDL to display bitmap

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
# There is nothing to install so we do it with hand
#make install DESTDIR=$RPM_BUILD_ROOT

mkdir -p $RPM_BUILD_ROOT%{_bindir}
mkdir -p $RPM_BUILD_ROOT%{_datadir}/%{name}
cp SDL_DisplayBitmap  $RPM_BUILD_ROOT%{_bindir}
chmod +x $RPM_BUILD_ROOT%{_bindir}/*
cp image.bmp $RPM_BUILD_ROOT%{_datadir}/%{name}

%clean
rm -rf $RPM_BUILD_ROOT

%files
%defattr(-,root,root,-)
%doc LICENSE.TXT
%{_bindir}
%dir %{_datadir}/%{name}
%{_datadir}/%{name}/*


%changelog
</pre>
<p>and copy our tar-ball to &#8216;/usr/src/packages/SOURCES&#8217;. After that we build rpmbuild command to create RPM packages</p>
<pre>
rpmbuild -ba sdl_displaybitmap.spec
</pre>
<p>If everything goes right you should have this RPM in &#8216;/usr/src/packages/RPMS/YOURARCHHERE/sdl_displaybitmap-1.0-1.YOURARCHHERE.rpm&#8217; and SRPM in &#8216;/usr/src/packages/SRPMS/sdl_displaybitmap-1.0-1.src.rpm&#8217;. You can check with less that what files it contains</p>
<pre>
less /usr/src/packages/RPMS/YOURARCHHERE/sdl_displaybitmap-1.0-1.YOURARCHHERE.rpm
</pre>
<p><strong>OBS</strong> If you install this RPM it won&#8217;t work! Application only works if you go to folder &#8216;/usr/share/sdl_displaybitmap&#8217; and run it there. Next time we patch our app to work from other places also.</p>
<h2>What does this mean?</h2>
<p>There is better documentation <a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package#Creating_a_SPEC_file" title="Creating a SPEC file">else where than I can write</a>. For openSUSE conventions see <a href="http://en.opensuse.org/Portal:Packaging" title="Portal:Packaging">Packaging in Wiki</a>. If you curious read it from there and learn. Next time we make OBS (openSUSE Build Service) build from this RPM and last part is how we use OBS to create also Debian, Ubuntu and Fedora packages from our marvelous app.</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2013/12/03/opensuse-and-gcc-part-8-rpms-and-how-to-write-them/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>openSUSE and GCC part 7: autotools and how I do it</title>
		<link>http://lizards.opensuse.org/2013/11/19/opensuse-and-gcc-part-7/</link>
		<comments>http://lizards.opensuse.org/2013/11/19/opensuse-and-gcc-part-7/#comments</comments>
		<pubDate>Tue, 19 Nov 2013 08:54:05 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[aclocal]]></category>
		<category><![CDATA[autoconf]]></category>
		<category><![CDATA[automake]]></category>
		<category><![CDATA[autotools]]></category>
		<category><![CDATA[C-Language]]></category>
		<category><![CDATA[libtool]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10147</guid>
		<description><![CDATA[Last time I was little bit too hard to autotools. Okay they are not easy but they work. I also let last time people to figure how to get a long with autotools. Now I show how I do it. Let&#8217;s dance First put some good music on and relax. Starting new project and trying [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><a href="//lizards.opensuse.org/2013/11/12/opensuse-and-gcc-part-6/" title="openSUSE and GCC part 6: Introduction to autotools">Last time I was little</a> bit too hard to autotools. Okay they are not easy but they work. I also let last time people to figure how to get a long with autotools. Now I show how I do it.<span id="more-10147"></span></p>
<h2>Let&#8217;s dance</h2>
<p>First put some good music on and relax. Starting new project and trying to get it compile is very unpleasant experience. Then read blog about <a href="//lizards.opensuse.org/2013/11/12/opensuse-and-gcc-part-6/" title="openSUSE and GCC part 6: Introduction to autotools">autotools</a> and then also see <a href="//lizards.opensuse.org/2013/10/28/opensuse-and-gcc-part4/" title="openSUSE and GCC part 4: Pkg-config and what one can do with it">example that I&#8217;ve been using</a>. Now you should have files: &#8216;configure.ac&#8217;, &#8216;Makefile.am&#8217;, &#8216;SDL_DisplayBitmap.c&#8217;, &#8216;LICENSE.TXT&#8217; and &#8216;image.bmp&#8217; in same directory/folder also you should have rpm libSDL_image-devel installed. Then we zypper needed autotools in. </p>
<pre>
zypper install libtool automake autoconf
</pre>
<p>after that we need to make directory contain needed scripts and M4-macros. You don&#8217;t need to copy them manually just make like this in console:</p>
<pre>
aclocal --force
libtoolize -c
automake --copy --add-missing
autoconf --force
</pre>
<p>So we run &#8216;aclocal&#8217; to copy those M4-macros after that we &#8216;libtoolize&#8217; our directory and then &#8216;automake&#8217; creates needed &#8216;Makefile.in&#8217; files from &#8216;Makefile.am&#8217;. Last &#8216;autoconf&#8217; creates configure-script from configure.ac. If everything went fine you ca continue:</p>
<pre>
./configure
make
./SDL_DisplayBitmap
</pre>
<p>Okay now it should work as expected. If you are interested you can try also</p>
<pre>
make dist
</pre>
<p>and you should have &#8216;SDL_DisplayBitmap-1.0.tar.gz&#8217; and &#8216;SDL_DisplayBitmap-1.0.tar.bz2&#8242; to distribute you application.</p>
<h2>Let&#8217;s dig further</h2>
<p>I&#8217;ll explain what these sentences mean in &#8216;configure.ac&#8217;:</p>
<pre>
AC_PREREQ([2.57])
AC_CONFIG_MACRO_DIR([m4])
</pre>
<p>Just tell what Autoconf is needed at least 2.57 and what is M4-macro directory (in this case it&#8217;s &#8216;m4&#8242;)</p>
<pre>
AC_INIT([SDL_DisplayBitmap], [1.0], [http&#058;//lizards.opensuse.org])
</pre>
<p>Let&#8217;s have application named SDL_DisplayBitmap which version is 1.0 and URL to see something more is http&#058;//lizards.opensuse.org</p>
<pre>
AM_INIT_AUTOMAKE([foreign dist-bzip2])
</pre>
<p>Initialize automake. We want &#8216;tar.bz2&#8242; package also made.</p>
<pre>
AC_LANG_C
AC_PROG_CC
AM_PROG_LIBTOOL
</pre>
<p>Make sure we have C++ and C-compiler and Libtools.</p>
<pre>
C_OPTIONS="-ansi -Wall -Werror -std=c99 -fno-strict-aliasing"
</pre>
<p>I use these C-Flags in my applications. You should use yours.</p>
<pre>
AC_SUBST(C_OPTIONS)
</pre>
<p>Make them available in Makefile.in/.am</p>
<pre>
PKG_CHECK_MODULES(SDL, SDL_image)
</pre>
<p>Check SDL_image from pkg-config and store it in SDL-prefix (SDL_LIBS and SDL_CFLAGS) variable.</p>
<pre>
AC_OUTPUT([Makefile])
</pre>
<p>Configure these files from configure here. In our case only use formulate Makefile.in file. </p>
<h2>Makefile.am</h2>
<p>Now it&#8217;s time to listen <em>Scorpions Still loving you</em> if don&#8217;t already listening it.</p>
<pre>
INCLUDES = $(SDL_CFLAGS) $(C_OPTIONS)
</pre>
<p>This actually old school way of doing it but it compatible downwards. We but our C_OPTIONS from configure.ac and SDL needed build flags in build.</p>
<pre>
EXTRA_DIST = LICENSE.TXT image.bmp
</pre>
<p>We also pack these files in distribution tar-ball.</p>
<pre>
noinst_PROGRAMS = SDL_DisplayBitmap
</pre>
<p>This tell we want to have binary named: &#8216;SDL_DisplayBitmap&#8217; that ain&#8217;t installed anywhere. If you but bin_PROGRAMS application will be installed to &#8216;/usr/local/bin&#8217; or &#8216;prefix/bin&#8217; you mentioned in &#8216;./configure &#8211;prefix=/prefix&#8217; (sbin_PROGRAMS will install it to &#8216;/usr/local/sbin&#8217;).</p>
<pre>
SDL_DisplayBitmap_SOURCES = SDL_DisplayBitmap.c
SDL_DisplayBitmap_LDFLAGS = $(SDL_LIBS)
</pre>
<p>Actually tell what sources belongs to SDL_DisplayBitmap and what libs are need to build this.</p>
<p>Yes that was so easy and nice. Next time is time to make RPM from our example application.</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2013/11/19/opensuse-and-gcc-part-7/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>openSUSE and GCC part 6: Introduction to autotools</title>
		<link>http://lizards.opensuse.org/2013/11/12/opensuse-and-gcc-part-6/</link>
		<comments>http://lizards.opensuse.org/2013/11/12/opensuse-and-gcc-part-6/#comments</comments>
		<pubDate>Tue, 12 Nov 2013 06:47:56 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[aclocal]]></category>
		<category><![CDATA[autoconf]]></category>
		<category><![CDATA[automake]]></category>
		<category><![CDATA[autotools]]></category>
		<category><![CDATA[C-Language]]></category>
		<category><![CDATA[libtool]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10114</guid>
		<description><![CDATA[Autotools, autotools and once again autotools. Years ago I started with autotools I thought, &#8216;Hey someone has really get into linking and compiling&#8217;. I was sold for a while and tried to learn it inside out. Then I understood that I will never be good at autotools (So I started to go to gym instead). [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><a href="http://en.wikipedia.org/wiki/GNU_build_system" title="Wikipedia autotools">Autotools, autotools and once again autotools</a>. Years ago I started with autotools I thought, &#8216;Hey someone has really get into linking and compiling&#8217;. I was sold for a while and tried to learn it inside out. Then I understood that I will never be good at <a href="http://www.gnu.org/savannah-checkouts/gnu/automake/manual/html_node/Autotools-Introduction.html" title="An Introduction to the Autotools">autotools</a> (So I started to go to gym instead). <a href="http://en.wikipedia.org/wiki/M4_%28computer_language%29" title="M4 language">M4 macro language</a> it is not my thing.<br />
It&#8217;s just something that should be put on one way Mars shuttle and send to gray ones to figure out. I think mr. Spock&#8217;s brains functioned with M4 but mine won&#8217;t. If there is some M4 specialist. Send me e-mail or post comment about it and tell why M4 is best macro language on earth. If nobody stands up for poor M4-macro language I&#8217;ll keep unloving it. I can start liking it because I was so wrong with <a href="http://en.wikipedia.org/wiki/REXX" title="Rexx">Rexx</a>.<span id="more-10114"></span></p>
<h2>Autotools</h2>
<p>Autotools are designed to work with GNU GCC (GNU Compiler Collection) and visa versa. You can use Autotools with any C-compiler or with any language but it works best when compiling GNU C or C++ applications. Autotools are actually four tools aclocal, <a href="http://www.gnu.org/software/libtool/" title="Libtool">libtool</a>, <a href="http://www.gnu.org/software/autoconf/" title="Autoconf">autoconf</a> and <a href="http://www.gnu.org/software/automake/" title="Automake">automake</a>.</p>
<h3>GNU aclocal</h3>
<p>It&#8217;s easier to tell what aclocal is not than what it is. Aclocal checks your needed M4 macros and copies or symlinks them to your project. I hope you never need to tackle with this or write your own M4 macro for find you great library (use pkg-config I say it once more use pkg-config) or new something that other M4 macros sucks to do. I don&#8217;t have anything else to say about this.</p>
<h3>GNU libtool</h3>
<p>If you like to make Share Objects (.so), Windows DLL or something your operating system supports libtool is your friend. You&#8217;ll need this anyways wanted or not.</p>
<h3>GNU autoconf</h3>
<p>This one is also strange tool. I compiles from M4 macros an &#8216;configure&#8217;-named bash script. So you have &#8216;configure.ac&#8217; M4 based script that is formulated to &#8216;configure&#8217;-named bash script and autoconf does that.</p>
<h3>GNU automake</h3>
<p><a href="//lizards.opensuse.org/2013/11/05/opensuse-and-gcc-part-5/" title="openSUSE and GCC part 5: Make love me do">Last time we talked about Makefiles</a> and how to use them with compiling. Autotools is make based. You can probably use other build tools but I never have seen them in use. Automake seeks for &#8216;Makefile.am&#8217; files and turns macros and stuff inside them to &#8216;Makefile.in&#8217; that is usable with &#8216;configure&#8217;-script from autoconf. Actually its not that simple but with this you can live you life happilly ever after.<br />
Because everyone wants to know <a href="https://www.lrde.epita.fr/~adl/autotools.html" title="Autotools Tutorial">everything these days read more here</a>.</p>
<h2>And this was complicated you moron!</h2>
<p>Yes I can admit it! I&#8217;m not very clever guy. When I was young I though hell there ain&#8217;t nobody that I better than me. Now I can admin there is and I&#8217;m just a ordinary guy from Finland. So you think you are more clever than me okay let&#8217;s test it. I&#8217;ll just throw you a bone and you tackle with by yourself and search machine (I won&#8217;t use that G-word there is so many other ones also). <a href="//lizards.opensuse.org/2013/10/28/opensuse-and-gcc-part4/" title="openSUSE and GCC part 4: Pkg-config and what one can do with it">Example is the same</a> that have been use in other posts and all the needed info is here so you should be able to figure this out by yourself and ask from mr. NSA the rest. Here are configure.ac and Makefile.am but how to utilize them? Good question.. hmm.. use zypper to install automake.. maybe.. maybe?</p>
<h3>configure.ac</h3>
<pre>
AC_PREREQ([2.57])
AC_CONFIG_MACRO_DIR([m4])
AC_INIT([SDL_DisplayBitmap], [1.0], [http&#058;//lizards.opensuse.org])
AM_INIT_AUTOMAKE([foreign dist-bzip2])

EXTRA_DIST = LICENSE.TXT image.bmp

AC_LANG_C
AC_PROG_CC
AM_PROG_LIBTOOL

C_OPTIONS="-ansi -Wall -Werror -std=c99 -fno-strict-aliasing"

AC_SUBST(C_OPTIONS)

PKG_CHECK_MODULES(SDL, SDL_image)

AC_OUTPUT([Makefile])</pre>
<h3>Makefile.am</h3>
<pre>
INCLUDES = $(SDL_CFLAGS) $(C_OPTIONS)

EXTRA_DIST = LICENSE.TXT image.bmp

noinst_PROGRAMS = SDL_DisplayBitmap

SDL_DisplayBitmap_SOURCES = SDL_DisplayBitmap.c
SDL_DisplayBitmap_LDFLAGS = $(SDL_LIBS)</pre>
<p>Now you have everything and go for the bad thing. Next time I&#8217;ll tell how I do it..</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2013/11/12/opensuse-and-gcc-part-6/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>openSUSE and GCC part 5: Make love me do</title>
		<link>http://lizards.opensuse.org/2013/11/05/opensuse-and-gcc-part-5/</link>
		<comments>http://lizards.opensuse.org/2013/11/05/opensuse-and-gcc-part-5/#comments</comments>
		<pubDate>Tue, 05 Nov 2013 07:03:08 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[Education]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[C-Language]]></category>
		<category><![CDATA[make]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10095</guid>
		<description><![CDATA[In this point of time if you haven&#8217;t any idea what is pkg-config or GCC you should be reading this. Or if you still do please make sure you read about them from these blog posts. &#8216;Make&#8216; as a tool doesn&#8217;t do anything easier it just hides not-so-easy-part from eyes of public. &#8216;Make&#8217;-tool executes (in [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>In this point of time if you haven&#8217;t any idea what is <a href="http://www.freedesktop.org/wiki/Software/pkg-config/" title="pkg-config">pkg-config</a> or <a href="http://gcc.gnu.org/" title="the GNU Compiler Collection">GCC</a> you should be reading this. Or if you still do please make sure you read about them from these <a href="//lizards.opensuse.org/2013/10/15/opensuse-and-gcc-part-2/" title="openSUSE and GCC part 2: compiling ‘Hello World’">blog</a> <a href="//lizards.opensuse.org/2013/10/28/opensuse-and-gcc-part4/" title="openSUSE and GCC part 4: Pkg-config and what one can do with it">posts</a>. &#8216;<a href="https://www.gnu.org/software/make/" title="GNU Make">Make</a>&#8216; as a tool doesn&#8217;t do anything easier it just hides not-so-easy-part from eyes of public. &#8216;Make&#8217;-tool executes (in default) Makefile-script that should tell how to build your applications step by step. There is no guaranties that it&#8217;s easier to understand how it&#8217;s build or you to understand that after a while.<span id="more-10095"></span></p>
<h2>What should I make then?</h2>
<p>As &#8216;make&#8217; spreads <a href="https://en.wikipedia.org/wiki/Make_%28software%29" title="Make (software)">wide area of operating system</a> it&#8217;s not very new tool. You can use make in AIX, HP/UX, BSD variants, Linux, Windows or Solaris. Most of them they got their own make tool that got it&#8217;s own dialect. If you are not using AIX, HP-UX, Solaris or pure nmake from Visual Studio I recommend to learn GNU Make dialect. With that you can easily adapt those others. One can pretend that &#8216;make&#8217; is nearly programming language for building application.<br />
Mostly because &#8216;make&#8217; ain&#8217;t cleanest way building applications there is also other tools as well: <a href="http://scons.org/" title="SCons">Python Scons</a>, <a href="https://ant.apache.org/" title="Apache Ant">Apache Ant</a> and <a href="http://cmake.org/" title="CMake">CMake</a> for example. They all are as powerful as &#8216;make&#8217; if compare them as building tools. You got to remeber Ant is mostly for Java applications but you can use it for anything if you are willing and SCons is general building tool. One can argue all the day and night which of them is the best. One thing is correct &#8216;make&#8217; <em>is not the cleanest</em> but is factory standard.</p>
<h2>First forget everything</h2>
<p>First thing I like to say about make is forget everything you have learned in your life. There is only one way on doing things in &#8216;make&#8217; and it&#8217;s only open for those who are true believers. Now forget those two sentences and you are in correct state of taking example building script as it is. This particular builds <a href="//lizards.opensuse.org/2013/10/28/opensuse-and-gcc-part4/" title="openSUSE and GCC part 4: Pkg-config and what one can do with it">last blogs</a> &#8216;SDL_image&#8217; example program. First we install make</p>
<pre>
zypper install make
</pre>
<p>then make script. Save this in sample directory/Folder as &#8216;SDL_DisplayBitmap.c&#8217; named &#8216;Makefile&#8217; (In this case capitals are needed). If you use pico/nano make sure intend tabs are tabs not spaces if they are converted make won&#8217;t work.</p>
<pre>
SRC := SDL_DisplayBitmap.c
CFLAGS = $(shell pkg-config --cflags SDL_image)
LIBS = $(shell pkg-config --libs SDL_image)

all: 
	@echo "Building with make is so fun"
	gcc -o SDL_DisplayBitmap $(SRC) $(CFLAGS) $(LIBS)

.PHONY: install clean

clean:
	rm -f SDL_DisplayBitmap

install:
	@echo "This just PHONY install target"
</pre>
<h2>What does it mean?</h2>
<p>Okay let&#8217;s go line by line</p>
<pre>
SRC := SDL_DisplayBitmap.c
</pre>
<p>Variable that contains &#8216;SDL_DisplayBitmap.c&#8217;. Why it got &#8216;:=&#8217; and no &#8216;=&#8217; that&#8217;s is up to you find out.</p>
<pre>
CFLAGS = $(shell pkg-config --cflags SDL_image)
LIBS = $(shell pkg-config --libs SDL_image)
</pre>
<p>This could be done in one variable but it&#8217;s easier to use in future if it&#8217;s divided in two. Tell to run &#8216;pkg-config&#8217;-tool and pass what ever is output to variable &#8216;CFLAGS&#8217; or &#8216;LIBS&#8217;. So they now have correct building flags and libraries.</p>
<pre>
all: 
&lt;TAB&gt;@echo "Building with make is so fun"
&lt;TAB&gt;gcc -o SDL_DisplayBitmap $(SRC) $(CFLAGS) $(LIBS)
</pre>
<p>Okay this is the main thing of &#8216;all:&#8217;-target. Traditionally there is &#8216;all&#8217;-target in &#8216;Makefile&#8217; to build applications from ground up.<br />
Now be attended! <strong>Always use intending tabs before commands in &#8216;Makefile&#8217; no spaces</strong>. Okay? If &#8216;make&#8217;-tool says you are using spaces to intend convert them to tabs. &#8216;@&#8217;-mark is just don&#8217;t show what we are doing only print what is outputted to stdout and after that we compile using SRC, CFLAGS and LIBS variables. If you are using variable in Makefile it have to be &#8216;$(VARIABLENAME)&#8217; not &#8216;$VARIABLENAME&#8217; or &#8216;VARIABLENAME&#8217;. You can also use lowercase names but again tradition and habits comes in a way.</p>
<pre>
.PHONY: install clean

clean:
&lt;TAB&gt;rm -f SDL_DisplayBitmap

install:
&lt;TAB&gt;@echo "This just PHONY install target"
</pre>
<p>Normally there is clean and install targets available in every &#8216;Makefile&#8217;. It&#8217;s more easier your life stuff than must. I recommend to create them! It will not lead you to hate or suffering. These targets are easy to explain &#8216;clean&#8217;-target should get you source tree in state that if was before building and &#8216;install&#8217;-target should install your binary/binaries. Ahh.. and then there is &#8216;.PHONY&#8217; target is you really are interested <a href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html" title=".PHONY Docs">read all about it from docs</a>.</p>
<h2>How to make application</h2>
<p>Copy Makefile to folder/directory you have &#8216;SDL_DisplayBitmap.c&#8217; and run</p>
<pre>
make
</pre>
<p>after that you should have binary &#8216;SDL_DisplayBitmap&#8217;. if you want to clean your source just run</p>
<pre>
make clean
</pre>
<p>This was just hands dirty example. Make is so much more and more complicated you ever can imagine. Next we jump into Autotools for couple of blogs as they use make as tools to build applications.</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2013/11/05/opensuse-and-gcc-part-5/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>openSUSE and GCC part 4: Pkg-config and what one can do with it</title>
		<link>http://lizards.opensuse.org/2013/10/28/opensuse-and-gcc-part4/</link>
		<comments>http://lizards.opensuse.org/2013/10/28/opensuse-and-gcc-part4/#comments</comments>
		<pubDate>Mon, 28 Oct 2013 16:37:38 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[Education]]></category>
		<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Miscellaneous]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[C-Language]]></category>
		<category><![CDATA[Gcc]]></category>
		<category><![CDATA[pkg-config]]></category>
		<category><![CDATA[rpm]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10083</guid>
		<description><![CDATA[When I re-booted my blogging habits with very UN-sexy and technical topic &#8216;GNU C Compiler and how to make it with openSUSE&#8217;. I thought nobody bothers to read these because A) Everyone who reads openSUSE blogs are PRO B) everyone wants to do Javascript, Python or &#8216;Put your script language here not C. I can [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>When I re-booted my blogging habits with very UN-sexy and technical topic &#8216;GNU C Compiler and how to make it with openSUSE&#8217;. I thought nobody bothers to read these because A) Everyone who reads openSUSE blogs are PRO B) everyone wants to do Javascript, Python or &#8216;Put your script language here not C. I can tell actually C ain&#8217;t that bad you just have to shoot yourself to leg and then learn how to walk again.<br />
Last blog entry was about &#8216;<a href="//lizards.opensuse.org/2013/10/22/opensuse-and-gcc-part-3/" title="openSUSE and GCC part 3: RPM devel packages">openSUSE and GCC part 3: RPM devel packages</a>&#8216; someone (thanks for pointing that out really!) noted that I should fix C-Code example I was stunned! There were someone that really readied blog entry. Okay he/she didn&#8217;t say did he/she like it but some one read it.<br />
I have one real reason to this blog-stuff. I hope I have found something like this when I young and I was starting my journey in Linux land. Currently there is so many more people now in populating it and it&#8217;s coming up fast. So If you find errors or don&#8217;t understand something be welcome to ask or want to know about something specific let me know! Now we get on today’s topic that is &#8216;pkg-config and what one can do with it&#8217;.<span id="more-10083"></span></p>
<h2>Pkg-config makes things easy/complicated (choose one)</h2>
<p>You can live you whole C developer life with Linux and GCC without ever toughing &#8216;<a href="http://www.freedesktop.org/wiki/Software/pkg-config/" title="pkg-config">pkg-config</a>&#8216;. pkg-config is just something that can make you life easier with C. It&#8217;s not easy to say in couple of words what it does but closest I can get it provides information how to compile application with specific C-library. In other words if you <a href="//lizards.opensuse.org/2013/10/22/opensuse-and-gcc-part-3/" title="openSUSE and GCC part 3: RPM devel packages">read blog before</a> there were these bare &#8216;gcc&#8217; library entries in command-line (-lname stuff).<br />
With more complicated libaries: like GTK+ or SDL you can get yourself wondering what libraries shall I include and what not that I can get my application build. Every self respecting developer wants to keep library dependencies as low as possible. So if you don&#8217;t want to wonder anymore you can use &#8216;pkg-config&#8217;.</p>
<h3>So what it really does?</h3>
<p>Last time I promised SDL_image 1.2 example as it&#8217;s little bit more complicated to get build. Actually it&#8217;s not that complicated but it&#8217;s simple example library and you get nice GUI stuff. First we have to zypper or YaST pkg-config, unzip and SDL_image-devel packages so we can use and link against SDL_image.</p>
<pre>
zypper install pkg-config SDL_image-devel unzip
</pre>
<p>after you have managed to install it you can download this blog example application made by <em>Ryan Clark</em> from here: &#8216;<a href="http://content.gpwiki.org/images/2/2f/SDL_DisplayBitmap.zip" title="SDL_DisplayBitmap.zip">SDL_DisplayBitmap.zip</a>&#8216;. It comes from nice <a href="http://content.gpwiki.org/index.php/SDL" title="SDL ">SDL gaming wiki</a> (<a href="http://content.gpwiki.org/index.php/SDL:Tutorials:Displaying_a_Bitmap" title="Displaying a Bitmap">This tutorial actually</a>) and so if you are interested making games with <a href="http://www.libsdl.org/" title="Simple Direct Layer">SDL 1.2 or 2.0</a> you should pop there. You can download files and unzip it or you can crap same source below and save it as &#8216;SDL_DisplayBitmap.c&#8217; if you do that remember to have some <a href="http://www.fileformat.info/format/bmp/egff.htm">BMP-image</a> in same directory where you compile named: &#8216;<em>image.bmp</em>&#8216;. Real nerds goes with unzip. If you do it <b>like me</b> it goes like this.</p>
<pre>
unzip SDL_DisplayBitmap.zip
cd SDL_DisplayBitmap
</pre>
<p>Or code for copying</p>
<pre>
// THIS WORK, INCLUDING THE SOURCE CODE, DOCUMENTATION
// AND RELATED MEDIA AND DATA, IS PLACED INTO THE PUBLIC DOMAIN.
//
// THE ORIGINAL AUTHOR IS RYAN CLARK.
//
// THIS SOFTWARE IS PROVIDED AS-IS WITHOUT WARRANTY
// OF ANY KIND, NOT EVEN THE IMPLIED WARRANTY OF
// MERCHANTABILITY. THE AUTHOR OF THIS SOFTWARE,
// ASSUMES _NO_ RESPONSIBILITY FOR ANY CONSEQUENCE
// RESULTING FROM THE USE, MODIFICATION, OR
// REDISTRIBUTION OF THIS SOFTWARE.

#include &lt;stdlib.h&gt;
#include &lt;SDL/SDL.h&amp;lgt;

int main(int argc, char *argv[])
{
	SDL_Surface *screen;	//This pointer will reference the backbuffer
	SDL_Surface *image;	//This pointer will reference our bitmap sprite
	SDL_Surface *temp;	//This pointer will temporarily reference our bitmap sprite
	SDL_Rect src, dest;	//These rectangles will describe the source and destination regions of our blit
	
	//We must first initialize the SDL video component, and check for success
	if (SDL_Init(SDL_INIT_VIDEO) != 0) {
		printf("Unable to initialize SDL: %s\n", SDL_GetError());
		return 1;
	}
	
	//When this program exits, SDL_Quit must be called
	atexit(SDL_Quit);
	
	//Set the video mode to fullscreen 640x480 with 16bit colour and double-buffering
	screen = SDL_SetVideoMode(640, 480, 16, SDL_DOUBLEBUF | SDL_FULLSCREEN);
	if (screen == NULL) {
		printf("Unable to set video mode: %s\n", SDL_GetError());
		return 1;
	}
	
	//Load the bitmap into a temporary surface, and check for success
	temp = SDL_LoadBMP("image.bmp");
	if (temp == NULL) {
		printf("Unable to load bitmap: %s\n", SDL_GetError());
		return 1;
	}
	
	//Convert the surface to the appropriate display format
	image = SDL_DisplayFormat(temp);
	
	//Release the temporary surface
	SDL_FreeSurface(temp);
	
	//Construct the source rectangle for our blit
	src.x = 0;
	src.y = 0;
	src.w = image-&gt;w;	//Use image-&gt;w to display the entire width of the image
	src.h = image-&gt;h;	//Use image-&gt;h to display the entire height of the image
	
	//Construct the destination rectangle for our blit
	dest.x = 100;		//Display the image at the (X,Y) coordinates (100,100)
	dest.y = 100;
	dest.w = image-&gt;w;	//Ensure the destination is large enough for the image's entire width/height
	dest.h = image-&gt;h;
	
	//Blit the image to the backbuffer
	SDL_BlitSurface(image, &amp;src, screen, &amp;dest);
	
	//Flip the backbuffer to the primary
	SDL_Flip(screen);
	
	//Wait for 2500ms (2.5 seconds) so we can see the image
	SDL_Delay(2500);
	
	//Release the surface
	SDL_FreeSurface(image);
	
	//Return success!
	return 0;
}
</pre>
<p>I chose this one because it doesn&#8217;t have any compiling aid for poor fellow in ZIP. So we can compile it in openSUSE and most of Linux distros like this:</p>
<pre>
gcc -o SDL_Display Bitmap SDL_DisplayBitmap.c $(pkg-config --libs --cflags SDL_image)
./SDL_Display
</pre>
<p>You should just see nice spaceship for 2.5 seconds nothing more or you own nice BMP-image.</p>
<h2>Do I have to be BASH wizard and what even is BASH?</h2>
<p>If you are reading this in openSUSE you probably use <a href="http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29" title="BASH">BASH (Bourne Again Shell)</a> and that is all I want to say about that. It&#8217;s not the topic and you can forget all about it. You don&#8217;t have to be wizard of BASH to understand what happens in that sentence above. again we are compiling with &#8216;<em>gcc</em>&#8216; file named &#8216;<em>SDL_DisplayBitmap.c</em>&#8216; to binary &#8216;<em>SDL_DisplayBitmap</em>&#8216;. New stuff starts after that. It just tells to BASH ask from &#8216;pkg-config&#8217; libraries and needed c-flags that comes with SDL_image and attach them here. If you just run you get something like this</p>
<pre>
pkg-config --libs --cflags SDL_image
-D_GNU_SOURCE=1 -D_REENTRANT -I/usr/include/SDL  -lSDL_image -lSDL -lpthread
</pre>
<p>So compile string is actual then</p>
<pre>
gcc -o SDL_Display Bitmap SDL_DisplayBitmap.c -D_GNU_SOURCE=1 -D_REENTRANT -I/usr/include/SDL  -lSDL_image -lSDL -lpthread
</pre>
<p>But in every distro tends to tune these cflags stuff and every release of &#8216;SDL_image&#8217; can tune needed libraries. This what you don&#8217;t want to know anything about! You don&#8217;t want to hassle openSUSE&#8217;s or Fedora&#8217;s or Ubuntu&#8217;s global building flags or include neither library locations by hand. You should just go with the automatic &#8216;pkg-config&#8217; way.  If I can give you one bit of advise other than always use suncream for libraries have &#8216;pkg-config&#8217;-config files and use them. Next we get on &#8216;make&#8217; and Makefiles. As I&#8217;m too lazy to copy&#8217;n'paste my &#8216;<em>gcc</em>&#8216; strings here.</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2013/10/28/opensuse-and-gcc-part4/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>openSUSE and GCC part 3: RPM devel packages</title>
		<link>http://lizards.opensuse.org/2013/10/22/opensuse-and-gcc-part-3/</link>
		<comments>http://lizards.opensuse.org/2013/10/22/opensuse-and-gcc-part-3/#comments</comments>
		<pubDate>Tue, 22 Oct 2013 06:11:31 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[C-Language]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[Gcc]]></category>
		<category><![CDATA[rpm]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10057</guid>
		<description><![CDATA[In last blog I explained how to compile application with Gnu C Compiler as knows as &#8216;gcc&#8216;. In blog I try to explain what are RPM devel packages and how to use them in C-application with &#8216;gcc&#8216;. RPM Package Manager RPM started as Redhat Package Manager but now it seems to get along with nesting [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><a href="//lizards.opensuse.org/2013/10/15/opensuse-and-gcc-part-2/" title="openSUSE and GCC part 2: compiling 'Hello World'">In last blog</a> I explained how to compile application with Gnu C Compiler as knows as &#8216;<em>gcc</em>&#8216;. In blog I try to explain what are RPM devel packages and how to use them in C-application with &#8216;<em>gcc</em>&#8216;.<span id="more-10057"></span></p>
<h2>RPM Package Manager</h2>
<p>RPM started as Redhat Package Manager but now it seems to get along with nesting acronym RPM Package Manager (Like GNU is acronym from GNU&#8217;s Not Unix) so it doesn&#8217;t mean anything special. There is neat how to install RPM in <a href="http://opensuse-guide.org/installpackage.php" title="openSUSE how to install RPM package">openSUSE-guide</a> and complete Wikipedia article <a href="http://en.wikipedia.org/wiki/RPM_Package_Manager" title="http://en.wikipedia.org/wiki/RPM_Package_Manager">about RPM</a>.</p>
<h3>RPM Packages what are they</h3>
<p>One can think RPM packages are just like <a href="https://en.wikipedia.org/wiki/ZIP_%28file_format%29" title="Zip (file format)">Zip archives</a> or <a href="https://en.wikipedia.org/wiki/Tar_%28computing%29" title="Tar ball">tar-balls</a> with binaries inside them so if you install rpm package it just knows where to copy application information to get this particular application running. Source RPM packages contains ways to build particular application to binary form so end user can make use of it. So simple is that. If it&#8217;s not you can read more from <a href="http://en.opensuse.org/Package_management" title="Package management">openSUSE wiki</a>.<br />
RPM packages are named after format &#8216;<em>project_name-version-build-arch</em>&#8216; they can be more difficult when we are dealing with C-libraries example <a href="http://www.gtk.org/" title="GTK+ Project">GUI library GTK3</a> is named after scheme &#8216;<em>liblibname-libversion-apiversion-version-build</em>&#8216;. Most of the libraries tends to follow that naming scheme.</p>
<h3>It just get fuzzier</h3>
<p>There is possibility to RPM have subpackages like &#8216;<em>project_name-subname-version-build-arch</em>&#8216;. There is three should know subpackages that are commonly available (most cases not)</p>
<ul>
<li>docs &#8211; contains doumentation</li>
<li>lang &#8211; contains localization</li>
<li>devel &#8211; hmm.. this one is little bit trickier</li>
</ul>
<h2>RPM devel packages</h2>
<p>Devel package contains files needed develop your/new application with library. If we use</p>
<pre>
rpm -ql libSDL_image-devel
</pre>
<p>we see as output what pacakge &#8216;libSDL_image-devel&#8217; really contains</p>
<pre>
/usr/include/SDL
/usr/include/SDL/SDL_image.h
/usr/lib64/libSDL_image.so
/usr/lib64/pkgconfig/SDL_image.pc</pre>
<p>what are all these files? There is one C-header file at least &#8216;<em>/usr/include/SDL/SDL_image.h</em>&#8216;. Then there seems to be &#8216;<em>/usr/lib64/libSDL_image.so</em>&#8216; symlink to C-library and &#8216;<em>/usr/lib64/pkgconfig/SDL_image.pc</em>&#8216; which I&#8217;ll get back in future blogs (since it make ones life easier). but what is &#8216;/usr/lib64/libSDL_image.so&#8217; file? Like said it&#8217;s <a href="https://en.wikipedia.org/wiki/Symbolic_link" title="Symbolic link">symbolic link</a> to C-library. you can check where it locates with (I assume you are using AMD64/x86_64 openSUSE if you are using something else like i586 use &#8216;<em>/usr/lib</em>&#8216; instead of &#8216;<em>/usr/lib64</em>&#8216;</p>
<pre>
readlink /usr/lib64/libSDL_image.so</pre>
<p>in my case it prints &#8216;<em>libSDL_image-1.2.so.0.8.4</em>&#8216;.</p>
<h3>Shared objects</h3>
<p>Microsoft Windows operating system have <a href="http://en.wikipedia.org/wiki/Dynamic-link_library" title="Dynamic-link library"><strong>DLL</strong></a> and Apple Mac OS X have <a href="http://www.osxbook.com/book/bonus/ancient/whatismacosx/programming.html" title="dyld"><strong>dylib</strong></a>. In linux world they are <a href="http://en.wikipedia.org/wiki/Dynamic_linker" title="Dynamic linker">Shared Objects</a> (<strong>.so</strong> files). Shared Objects contains all the library functions in binary format. So you can link your applications with it (If you have headers).<br />
GCC Linker (ld) seeks only for &#8216;<strong>.so</strong>&#8216; ending file but in these days most of the Shared Objects follow <a href="http://unix.stackexchange.com/questions/475/how-do-so-shared-object-numbers-work" title="How do SO (shared object) numbers work?">scheme with number file-ending</a> which is &#8216;so.API.MINOR.PATCH&#8217;. Every API numbering (greater that 0) should be compatible with each other. If new functions are in place older stays <a href="http://en.wikipedia.org/wiki/API" title="Application programming interface">API</a>/<a href="http://en.wikipedia.org/wiki/Application_binary_interface" title="Application binary interface">ABI</a> compatible. It should be like that so &#8216;<em>so.1.0.0</em>&#8216; is normally first stable. version &#8216;<em>so.1.0.1</em>&#8216; there is bug fixed and &#8216;<em>so.1.1.0</em>&#8216; there is new functions declared. It can be like that or project has adapted it&#8217;s own system.</p>
<h2>How to use these files</h2>
<p>I wondered what would be easy enough example with this? I Thought <a href="https://en.wikipedia.org/wiki/Ncurses" title="NCurses">NCurses</a> would do just fine. So copy text from <a href="http://www.paulgriffiths.net/program/c/srcs/curhell2src.html" title="NCurses Hello World in color">Paul Griffiths Ncurses Hello World example</a> or below to file &#8216;<em>ncurseshelloworld.c</em>&#8216;:</p>
<pre>
/*

  CURHELL2.C
  ==========
  (c) Copyright Paul Griffiths 1999
  Email: mail@paulgriffiths.net

  "Hello, world!", ncurses style (now in colour!)

*/

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;                  /*  for sleep()  */
#include &lt;curses.h&gt;

int main(void) {

    WINDOW * mainwin;

    /*  Initialize ncurses  */

    if ( (mainwin = initscr()) == NULL ) {
	fprintf(stderr, "Error initialising ncurses.\n");
	exit(EXIT_FAILURE);
    }

    start_color();                    /*  Initialize colours  */

    /*  Print message  */

    mvaddstr(6, 32, " Hello, world! ");

    /*  Make sure we are able to do what we want. If
	has_colors() returns FALSE, we cannot use colours.
	COLOR_PAIRS is the maximum number of colour pairs
	we can use. We use 13 in this program, so we check
	to make sure we have enough available.               */

    if ( has_colors() &amp;&amp; COLOR_PAIRS &gt;= 13 ) {

	int n = 1;

	/*  Initialize a bunch of colour pairs, where:

	        init_pair(pair number, foreground, background);

	    specifies the pair.                                  */

	init_pair(1,  COLOR_RED,     COLOR_BLACK);
	init_pair(2,  COLOR_GREEN,   COLOR_BLACK);
	init_pair(3,  COLOR_YELLOW,  COLOR_BLACK);
	init_pair(4,  COLOR_BLUE,    COLOR_BLACK);
	init_pair(5,  COLOR_MAGENTA, COLOR_BLACK);
	init_pair(6,  COLOR_CYAN,    COLOR_BLACK);
	init_pair(7,  COLOR_BLUE,    COLOR_WHITE);
	init_pair(8,  COLOR_WHITE,   COLOR_RED);
	init_pair(9,  COLOR_BLACK,   COLOR_GREEN);
	init_pair(10, COLOR_BLUE,    COLOR_YELLOW);
	init_pair(11, COLOR_WHITE,   COLOR_BLUE);
	init_pair(12, COLOR_WHITE,   COLOR_MAGENTA);
	init_pair(13, COLOR_BLACK,   COLOR_CYAN);

	/*  Use them to print of bunch of "Hello, world!"s  */

	while ( n &lt;= 13 ) {
	    color_set(n, NULL);
	    mvaddstr(6 + n, 32, &quot; Hello, world! &quot;);
	    n++;
	}
    }

    /*  Refresh the screen and sleep for a
	while to get the full screen effect  */

    refresh();
    sleep(3);

    /*  Clean up after ourselves  */

    delwin(mainwin);
    endwin();
    refresh();

    return EXIT_SUCCESS;
}</pre>
<p>if you just try to compile it with</p>
<pre>
gcc -o ncurseshelloworld ncurseshelloworld.c
/tmp/cc7CD9vN.o: In function `main':
ncurseshelloworld.c:(.text+0x9): undefined reference to `initscr'
ncurseshelloworld.c:(.text+0x41): undefined reference to `start_color'
ncurseshelloworld.c:(.text+0x48): undefined reference to `stdscr'
ncurseshelloworld.c:(.text+0x5a): undefined reference to `wmove'
ncurseshelloworld.c:(.text+0x66): undefined reference to `stdscr'
ncurseshelloworld.c:(.text+0x78): undefined reference to `waddnstr'
ncurseshelloworld.c:(.text+0x7d): undefined reference to `has_colors'
ncurseshelloworld.c:(.text+0x8b): undefined reference to `COLOR_PAIRS'
ncurseshelloworld.c:(.text+0xaf): undefined reference to `init_pair'
ncurseshelloworld.c:(.text+0xc3): undefined reference to `init_pair'
ncurseshelloworld.c:(.text+0xd7): undefined reference to `init_pair'
ncurseshelloworld.c:(.text+0xeb): undefined reference to `init_pair'
ncurseshelloworld.c:(.text+0xff): undefined reference to `init_pair'
/tmp/cc7CD9vN.o:ncurseshelloworld.c:(.text+0x113): more undefined references to `init_pair' follow
/tmp/cc7CD9vN.o: In function `main':
ncurseshelloworld.c:(.text+0x1ae): undefined reference to `stdscr'
ncurseshelloworld.c:(.text+0x1bd): undefined reference to `wcolor_set'
ncurseshelloworld.c:(.text+0x1ca): undefined reference to `stdscr'
ncurseshelloworld.c:(.text+0x1d9): undefined reference to `wmove'
ncurseshelloworld.c:(.text+0x1e5): undefined reference to `stdscr'
ncurseshelloworld.c:(.text+0x1f7): undefined reference to `waddnstr'
ncurseshelloworld.c:(.text+0x208): undefined reference to `stdscr'
ncurseshelloworld.c:(.text+0x210): undefined reference to `wrefresh'
ncurseshelloworld.c:(.text+0x226): undefined reference to `delwin'
ncurseshelloworld.c:(.text+0x22b): undefined reference to `endwin'
ncurseshelloworld.c:(.text+0x232): undefined reference to `stdscr'
ncurseshelloworld.c:(.text+0x23a): undefined reference to `wrefresh'
collect2: error: ld returned 1 exit status</pre>
<p>so what to do? Probably you already have ncurses Development package installed like me but if not first install ncurses devel rpm to you system</p>
<pre>
zypper install ncurses-devel</pre>
<p>then we little bit make our gcc line different:</p>
<pre>
gcc -o ncurseshelloworld ncurseshelloworld.c -lncurses
./ncurseshelloworld</pre>
<p>which &#8216;-l&#8217; tells you how to use ncurses library when seeking dependencies, After that you see many colors. So that was that and next time we go little bit into SDL_image 1.2 world and learn how to use pkg-config so we know what libraries are needed.</p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2013/10/22/opensuse-and-gcc-part-3/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>openSUSE and GCC part 2: compiling &#8216;Hello World&#8217;</title>
		<link>http://lizards.opensuse.org/2013/10/15/opensuse-and-gcc-part-2/</link>
		<comments>http://lizards.opensuse.org/2013/10/15/opensuse-and-gcc-part-2/#comments</comments>
		<pubDate>Tue, 15 Oct 2013 05:43:00 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Miscellaneous]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[C-Language]]></category>
		<category><![CDATA[Education]]></category>
		<category><![CDATA[openSUSE]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10010</guid>
		<description><![CDATA[I really hope you readied last article &#8216;OpenSUSE and GCC part 1: getting started&#8216; or you understand basics and you have GCC (Only GNU C Compiler as GCC stands Gnu Compiler Collection) installed. This time we learn how to compile application called &#8216;Hello World&#8217;. It&#8217;s so popular application even wikipedia have article about it. If [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>I really hope you readied last article &#8216;<a href="//lizards.opensuse.org/2013/10/07/opensuse-and-gcc-part1/" title="OpenSUSE and GCC part 1: getting started">OpenSUSE and GCC part 1: getting started</a>&#8216; or you understand basics and you have GCC (Only GNU C Compiler as GCC stands Gnu Compiler Collection) installed. This time we learn how to compile application called &#8216;Hello World&#8217;. It&#8217;s so popular application even <a href="https://en.wikipedia.org/wiki/Hello_World" title="Hello world program">wikipedia have article about it</a>. <span id="more-10010"></span>If you are not in reading mood I&#8217;ll explain it in short.</p>
<h2>Hello world</h2>
<p>Hello world is small application that programmer tends to start with when learning new programming language. It&#8217;s just something that prints &#8216;Hello World&#8217;-string in console. It&#8217;s good starting point to learn new programming language as in compiling languages you get the idea how to make application run.<br />
Github is the programming project hosting place that uses <a href="http://git-scm.com/" title="Git SCM">git</a>. If you adventurous you can see all the language &#8216;Hello World&#8217; programs from this <a href="https://github.com/git/hello-world" title="Hello World Github">Github page</a>. Just click them around and see that every program has the same idea. If you have no clue what all this means don&#8217;t feel bad! I hope in some point of you openSUSE hacking time you probably get back there and understand value of that small application.<br />
In C-Language &#8216;Hello World&#8217; looks like this:</p>
<pre>
#include &#060;stdio.h&#062;

int main(void) {
printf("Hello World\n");
return 0;
}</pre>
<p>Copy these sentences as they are to &#8216;<em>helloworld.c</em>&#8216; file with <a href="https://en.wikipedia.org/wiki/Pico_%28text_editor%29" title="Pico editor">pico</a>, <a href="http://nano-editor.org/" title="Nano editor">nano</a>, <a href="http://www.vim.org/" title="Vi improved">vim</a>, <a href="https://www.gnu.org/software/emacs/" title="GNU Emacs">emacs</a>, <a href="https://projects.gnome.org/gedit/" title="Gnome Gedit">gedit</a>, <a href="http://kate-editor.org/" title="Kate editor">kate</a> or some other text editor. Pay some attention where you save that &#8216;helloworld.c&#8217;. Easiest place would be you home dirs root /home/&#8217;yourusername&#8217;/. I won&#8217;t tell you want all this C-language means if you are <a href="http://www.cprogramming.com/tutorial/c/lesson1.html" title="Introduction to C">interested please read how to get along with C</a> and you see how easy language C really is.</p>
<h2>Compiling</h2>
<p>If you have used PHP, Python, Bash or Perl (maybe Ruby) in other words some programming language that doesn&#8217;t need compiling you are point of life to take a deep breath. If you have ever touched any programming language you in my position when I was 16 and started typing in <a href="https://en.wikipedia.org/wiki/Borland_Turbo_C%2B%2B" title="Borland Turbo C++">Borland Turbo C++</a> and take event deeper breath. If you have used Microsoft Visual Studio and which is incredible piece of IDE and you tell yourself you know something about programming you take mild breathe and zip of water. Only problem with IDEs is you never know how the magic happens behind the scenes. Specially Visual Studio is very very good make you application just compile and in most of the cases that is what you want right?<br />
There is some cases you need to get in the bottom and understand basic of compiling process. I tell one example from my life. In some point of my life I was ext in Nokia (Way before it was Microsoft owned phone company) and their phone build scripts were in HP-UX or AIX (can&#8217;t remember anymore sorry). There were nearly &#8216;NaN&#8217; of people who understand how these Makefile scripts worked (they were mostly very cryptic cross compile Makefile stuff) and they just saw my fellow ext-buddy sitting there behind his desk. They gave these scripts to this poor fellow and weeks he cried, moaned and felt pain in his brains from compiling extremely complicated application. In the end he did it. He made those build scripts to work because he understand how compiling and linking was actually made and if I’m not wrong he got work place from Nokia for years to come.<br />
Now I Cut the sentimental crap and tell how to compile program. It&#8217;s easy go to directory you have created &#8216;<em>helloworld.c</em>&#8216; and write this in console</p>
<pre>
gcc -o helloworld helloworld.c</pre>
<p>was it so hard? In setence &#8216;<em>gcc</em>&#8216; is GNU C Compiler and paramter &#8216;<strong>-o</strong>&#8216; is application binary name (choose wisely young badawan it will write over your files if have same file name).</p>
<h2>Run program</h2>
<p>Running the program isn&#8217;t hard at all. Stay in directory that program is and write to console</p>
<pre>
./helloworld
Hello World</pre>
<p>Now you have compiled you first program. Next we look at RPM devel packages and using libraries and headers. <strong>Remember &#8216;./&#8217; is very needed in front this example because you want to run application from your current location.</strong></p>
]]></content:encoded>
			<wfw:commentRss>http://lizards.opensuse.org/2013/10/15/opensuse-and-gcc-part-2/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
