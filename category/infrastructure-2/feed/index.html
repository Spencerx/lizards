<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Infrastructure &#8211; openSUSE Lizards</title>
	<atom:link href="https://lizards.opensuse.org/category/infrastructure-2/feed/" rel="self" type="application/rss+xml" />
	<link>https://lizards.opensuse.org</link>
	<description>Blogs and Ramblings of the openSUSE Members</description>
	<lastBuildDate>Fri, 06 Mar 2020 11:29:40 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.7.5</generator>
	<item>
		<title>Tricks with IPFS</title>
		<link>https://lizards.opensuse.org/2019/08/07/tricks-with-ipfs/</link>
		<pubDate>Wed, 07 Aug 2019 19:45:06 +0000</pubDate>
		<dc:creator><![CDATA[bmwiedemann]]></dc:creator>
				<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[Security]]></category>
		<category><![CDATA[Server]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=13968</guid>
		<description><![CDATA[Since April I am using IPFS Now I wanted to document some neat tricks and details. When you have the hex-encoded sha256sum of a small file &#8211; for this example let&#8217;s use the GPLv3.txt on our media &#8211; sha256sum /ipns/opensuse.zq1.de/tumbleweed/repo/oss/GPLv3.txt 8ceb4b9ee5adedde47b31e975c1d90c73ad27b6b165a1dcd80c7c545eb65b90 Then you can use the hash to address content directly by prefixing it with [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Since April I am  <a href="https://lizards.opensuse.org/2019/04/03/experimental-opensuse-mirror-via-ipfs/">using IPFS</a></p>
<p>Now I wanted to document some neat tricks and details.</p>
<p>When you have the hex-encoded sha256sum of a small file &#8211; for this example let&#8217;s use the GPLv3.txt on our media &#8211;<br />
<code>sha256sum /ipns/opensuse.zq1.de/tumbleweed/repo/oss/GPLv3.txt<br />
8ceb4b9ee5adedde47b31e975c1d90c73ad27b6b165a1dcd80c7c545eb65b90</code></p>
<p>Then you can use the hash to address content directly by prefixing it with /ipfs/f01551220 so it becomes</p>
<p>/ipfs/f015512208ceb4b9ee5adedde47b31e975c1d90c73ad27b6b165a1dcd80c7c545eb65b903</p>
<p>In theory this also works with SHA1 and the /ipfs/f01551114 prefix, but then you risk experiencing non-unique content like<br />
/ipfs/f0155111438762cf7f55934b34d179ae6a4c80cadccbb7f0a</p>
<p>And dont even think about using MD5.</p>
<p>For this trick to work, the file needs to be added with <code>ipfs add --raw-leaves</code> and it must be a single chunk &#8211; by default 256kB or smaller, but if you do the adding, you can also use larger chunks.</p>
<p>Here is a decoding of the different parts of the prefix:<br />
/ipfs/ is the common path for IPFS-addressed content<br />
f is the <a href="https://github.com/multiformats/multibase">multibase prefix</a> for hex-encoded data<br />
01 is for the <a href="https://docs.ipfs.io/guides/concepts/cid/#version-1">CID version 1</a><br />
55 is for <a href="https://github.com/multiformats/multicodec/blob/master/table.csv#L34">raw binary</a><br />
12 is for <a href="https://github.com/multiformats/multicodec/blob/master/table.csv#L6">sha2-256</a> (the default hash in IPFS)<br />
20 is for 32 byte = 256 bit length of hash</p>
<p>And finally, you can also access this content via the various IPFS-web-gateways:<br />
<a href="https://ipfs.io/ipfs/f015512208ceb4b9ee5adedde47b31e975c1d90c73ad27b6b165a1dcd80c7c545eb65b903">https://ipfs.io/ipfs/f015512208ceb4b9ee5adedde47b31e975c1d90c73ad27b6b165a1dcd80c7c545eb65b903</a></p>
<p>You can also do the same trick with other multibase encodings of the same data &#8211; e.g. <a href="https://ipfs.io/ipfs/010101010100010010001000001000110011101011010010111001111011100101101011011110110111011110010001111011001100011110100101110101110000011101100100001100011100111010110100100111101101101011000101100101101000011101110011011000000011000111110001010100010111101011011001011011100100000011">base2</a></p>
<p>Base2 looks pretty geeky, but so far I have not found practical applications.</p>
]]></content:encoded>
			</item>
		<item>
		<title>Debugging jenkins</title>
		<link>https://lizards.opensuse.org/2019/07/31/debugging-jenkins/</link>
		<comments>https://lizards.opensuse.org/2019/07/31/debugging-jenkins/#comments</comments>
		<pubDate>Wed, 31 Jul 2019 08:04:23 +0000</pubDate>
		<dc:creator><![CDATA[bmwiedemann]]></dc:creator>
				<category><![CDATA[Documentation]]></category>
		<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[Quality Assurance]]></category>
		<category><![CDATA[CI]]></category>
		<category><![CDATA[jenkins]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=13945</guid>
		<description><![CDATA[We had strange near-daily outages of our internal busy jenkins for some weeks. To get to the root cause of the issue, we enabled remote debugging with -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9010 -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=ci.suse.de -Dcom.sun.management.jmxremote.password.file=/var/lib/jenkins/jmxremote.password and attached visualvm to see what it was doing. This showed the number of threads and memory usage in a sawtooth pattern. Every [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>We had strange near-daily outages of our internal busy jenkins for some weeks.</p>
<p>To get to the root cause of the issue, we enabled remote debugging with</p>
<blockquote><p>
-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9010 -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=ci.suse.de -Dcom.sun.management.jmxremote.password.file=/var/lib/jenkins/jmxremote.password</p></blockquote>
<p>and attached visualvm to see what it was doing.<br />
This showed the number of threads and memory usage in a sawtooth pattern. Every time the garbage collector ran, it dropped 500-1000 threads.</p>
<p>Today we noticed that every time it threw these <code>java.lang.OutOfMemoryError: unable to create new native thread</code> errors, the maximum number of threads was 2018&#8230; suspiciously close to 2048. Looking for the same time in journalctl showed<br />
<code>kernel: cgroup: fork rejected by pids controller in /system.slice/jenkins.service</code></p>
<p>So it was systemd refusing java&#8217;s request for a new thread and jenkins not handling that gracefully in all cases.<br />
That was easily avoided with a<br />
<code>TasksMax=8192</code></p>
<p>Now the new peak was at 4890 live threads and jenkins served all Geekos happily ever after.</p>
]]></content:encoded>
			<wfw:commentRss>https://lizards.opensuse.org/2019/07/31/debugging-jenkins/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>experimental openSUSE mirror via IPFS</title>
		<link>https://lizards.opensuse.org/2019/04/03/experimental-opensuse-mirror-via-ipfs/</link>
		<comments>https://lizards.opensuse.org/2019/04/03/experimental-opensuse-mirror-via-ipfs/#comments</comments>
		<pubDate>Wed, 03 Apr 2019 13:41:39 +0000</pubDate>
		<dc:creator><![CDATA[bmwiedemann]]></dc:creator>
				<category><![CDATA[Distribution]]></category>
		<category><![CDATA[Factory]]></category>
		<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[Security]]></category>
		<category><![CDATA[Toolchain]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=13716</guid>
		<description><![CDATA[The InterPlanetary File System (IPFS) can be used to provide files in a more efficient and distributed way than HTTP. Our filesystem repo already has the go-ipfs client. You use it with ipfs daemon --init And then you can add my Tumbleweed mirror with zypper ar http://127.0.0.1:8080/ipns/opensuse.zq1.de./tumbleweed/repo/oss/ ipfs-oss You can also browse the content online [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>The <a href="https://en.wikipedia.org/wiki/InterPlanetary_File_System">InterPlanetary File System</a> (IPFS) can be used to provide files in a more efficient and distributed way than HTTP.</p>
<p>Our <a href="https://software.opensuse.org/package/go-ipfs">filesystem repo</a> already has the go-ipfs client.</p>
<p>You use it with<br />
<code>ipfs daemon --init</code></p>
<p>And then you can add my Tumbleweed mirror with<br />
<code>zypper ar http://127.0.0.1:8080/ipns/opensuse.zq1.de./tumbleweed/repo/oss/ ipfs-oss</code></p>
<p>You can also browse the content online at<br />
<a href="http://opensuse.zq1.de./tumbleweed/repo/oss/">http://opensuse.zq1.de./tumbleweed/repo/oss/</a> . During my testing I found that the results are sometimes inappropriately cached on the Cloudflare CDN, so if you used it under this URL without the ipfs client, this might throw signature errors in zypper.</p>
<p>On the server side, the mirror is updated using the <code>syncopensuse</code> script from<br />
<a href="https://github.com/bmwiedemann/opensusearchive">https://github.com/bmwiedemann/opensusearchive</a> and consistency of the repo is verified with <code>checkrepo</code></p>
<p>When a complete repo was synced, <a href="https://github.com/bmwiedemann/dynaname">dynaname</a> updates a DNS entry to point to the new head:</p>
<blockquote><p>
&gt; host -t txt _dnslink.opensuse.zq1.de.<br />
_dnslink.opensuse.zq1.de is an alias for tumbleweedipfs.d.zq1.de.<br />
tumbleweedipfs.d.zq1.de descriptive text &#8220;Last update: 2019-04-03 12:23:43 UTC&#8221;<br />
tumbleweedipfs.d.zq1.de descriptive text &#8220;dnslink=/ipfs/QmSXEVuU5z23rDxMyFYDhSAUaGRUPswuSXD3aVsBEzucjE&#8221;</p></blockquote>
<p>If you got spare bandwidth and 300 GB disk on some public server, you could also host a mirror of today&#8217;s version, simply by doing <code>ipfs pin add QmSXEVuU5z23rDxMyFYDhSAUaGRUPswuSXD3aVsBEzucjE</code></p>
<p>This is a permalink: <a href="http://127.0.0.1:8080/ipfs/QmSXEVuU5z23rDxMyFYDhSAUaGRUPswuSXD3aVsBEzucjE">http://127.0.0.1:8080/ipfs/QmSXEVuU5z23rDxMyFYDhSAUaGRUPswuSXD3aVsBEzucjE</a> also browsable via <a href="https://cloudflare-ipfs.com/ipfs/QmSXEVuU5z23rDxMyFYDhSAUaGRUPswuSXD3aVsBEzucjE">any public IPFS gateway</a>. This means, it will always remain on the 20190401 version of Tumbleweed and no changes in content are possible &#8211; similar to how a git commit ID always refers to the same data.</p>
<p>So why did I create this IPFS mirror? That is related to my work on <a href="https://en.opensuse.org/openSUSE:Reproducible_Builds">reproducible builds for openSUSE</a>. There it regularly happened that published Tumbleweed binaries were built with libraries, compilers and toolchains that were no longer available in current Tumbleweed. This prevented me from verifying that the published binaries were indeed built correctly without manipulation on the OBS build workers.</p>
<p>Now, with this archive of rpms easily available, it was possible to verify many more Tumbleweed packages than before. And most importantly, it remains possible to independently verify even after Tumbleweed moves on to newer versions. This data is going to stay available as long as anyone pins it on a reachable server. I&#8217;m going to pin it as long as it remains relevant to me, so probably a bit until after the next full Tumbleweed rebuild &#8211; maybe 6 to 12 months.</p>
<p>Thus, it now is even less easy to sneak in binary backdoors during our package build process.</p>
]]></content:encoded>
			<wfw:commentRss>https://lizards.opensuse.org/2019/04/03/experimental-opensuse-mirror-via-ipfs/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
		</item>
		<item>
		<title>Using openSUSE as a reverse tunnel site for Windows 7 or 8.1 remote desktop</title>
		<link>https://lizards.opensuse.org/2015/04/20/using-opensuse-as-a-reverse-tunnel-site-for-windows-7-remote-desktop/</link>
		<pubDate>Mon, 20 Apr 2015 02:43:56 +0000</pubDate>
		<dc:creator><![CDATA[Greg Freemyer]]></dc:creator>
				<category><![CDATA[Infrastructure]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=11334</guid>
		<description><![CDATA[If you can&#8217;t open a hole in your office / home firewall then a reverse tunnel can let you workaround the issue.  This blog post uses cygwin, ssh and autossh to create and maintain a reverse tunnel through your firewall. You should be aware that if you follow the below steps you will punch a hole [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>If you can&#8217;t open a hole in your office / home firewall then a reverse tunnel can let you workaround the issue.  This blog post uses cygwin, ssh and autossh to create and maintain a reverse tunnel through your firewall.</p>
<p style="padding-left: 30px"><span style="text-decoration: underline">You should be aware that if you follow the below steps you will punch a hole through your firewall, so be sure and consider the security issues associated with that hole.  Many organizations require security beyond a simple login and password when connectivity is allowed from outside the firewall.  In some organizations following the below instructions without authorization from your IT security team could be a firing offense.</span></p>
<p>In theory this functionality is relatively basic, but there are lots of resources on the web that only serve to complicate the matter.  The below instructions were followed in 2015 with current SSH to create an actual working reverse tunnel.</p>
<p><strong>The assumed situation is you have:</strong></p>
<p>&#8211; Windows 7 or 8.1 PC behind a firewall you want to remote desktop to (the target PC)<br />
&#8211; A openSUSE server in the cloud that you are able to ssh into and open appropriate ports and firewall holes<br />
&#8211; A client PC from which you want to originate Remote Desktop sessions</p>
<p>The instructions here borrow heavily from the below blog post, but I was unable to get the tunnels to work by following the steps described at that site:</p>
<blockquote data-secret="T7h3VyxJS9" class="wp-embedded-content"><p><a href="http://blog.yucas.mx/2012/11/22/creating-persistent-ssh-tunnels-in-windows-using-autossh/">Creating persistent SSH tunnels in Windows using autossh</a></p></blockquote>
<p><iframe class="wp-embedded-content" sandbox="allow-scripts" security="restricted" style="display:none;" src="http://blog.yucas.mx/2012/11/22/creating-persistent-ssh-tunnels-in-windows-using-autossh/embed/#?secret=T7h3VyxJS9" data-secret="T7h3VyxJS9" width="500" height="282" title="Entrada de WordPress incrustada" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></p>
<p>What has worked for me so far is:</p>
<ol>
<li>On the openSUSE server
<ol>
<li>Ensure you have a user account &#8220;autossh&#8221; (or whatever you want to call it).  This will be used exclusively for reverse tunnels.</li>
<li>Ensure you have a normal user account you can use with scp with to copy files from the target PC to the openSUSE server.</li>
</ol>
</li>
<li>On the target (destination) PC:
<ol>
<li>Ensure you have remote desktop setup.  Machines on the local LAN should be able to remote desktop into the PC prior to starting this procedure.</li>
<li>Download Cygwin (http://www.cygwin.com/)</li>
<li>Install Cygwin, selecting the autossh and openssh packages.</li>
<li>Start the Cygwin shell (Start -&gt; Programs -&gt; Cygwin).</li>
<li>Generate a public/private key pair.
<ol>
<li>At the command line, run: ssh-keygen</li>
<li>Accept the default file locations</li>
<li>Use an empty passphrase</li>
</ol>
</li>
<li>Copy your newly-created public key to the SSH server.
<ol>
<li>scp .ssh/id_rsa.pub user_account@ssh.host.name:id_rsa.pub</li>
</ol>
</li>
</ol>
</li>
<li>Add your public key to your list of authorized keys on the server.
<ol>
<li>Login to your SSH server as your normal user_account</li>
<li> mv id_rsa.pub  /tmp</li>
<li>su &#8211;  # become root</li>
<li>Ensure /home/autossh/.ssh exists
<ol>
<li># ls -ld /home/autossh/.ssh<br />
drwxr-xr-x 2 autossh users 4096 Apr 24 2015 /home/autossh/.ssh</li>
<li>If not: mkdir /home/autossh/.ssh; chown autossh.users /home/autossh/.ssh; chmod 755 /home/autossh/.ssh</li>
</ol>
</li>
<li>cat /tmp/id_rsa.pub &gt;&gt;  /home/autossh/.ssh/authorized_keys</li>
</ol>
</li>
<li>Tweak the sshd_config on the server
<ol>
<li>By default openSUSE enables &#8220;AllowTcpForwarding&#8221; and &#8220;TCPKeepAlive&#8221;. Verify they are either commented out or set to &#8220;yes&#8221; in /etc/ssh/sshd_config</li>
<li>Set &#8220;GatewayPorts yes&#8221; and &#8220;ClientAliveInterval 300&#8221; in /etc/ssh/sshd_config.  Also make sure they are not commented out.</li>
<li>restart sshd to get the config values to be re-read:    sudo systemctl restart sshd.service</li>
</ol>
</li>
<li>Test your SSH key.
<ol>
<li>Logout of your SSH sever.</li>
<li>Login to your SSH server again, but as autossh this time. This time, your key will be used for authentication and you won’t be challenged for your login credentials. If you are not logged in automatically, review the previous steps. Or contact your server administrator.
<ol>
<li>ssh autossh@@ssh.host.name</li>
</ol>
</li>
<li>Logout of your SSH server.</li>
<li>Exit of the Cygwin shell.</li>
</ol>
</li>
<li>Test your SSH Tunnel capability
<ol>
<li>Open a cmd prompt on your target PC as administrator
<ol>
<li>start -&gt; run -&gt; cmd -&gt; right click on &#8220;cmd&#8221; -&gt; left click &#8220;run as administrator&#8221;</li>
</ol>
</li>
<li>C:\cygwin\bin\ssh -N -R 4489:localhost:3389 autossh@ssh.host.name
<ol>
<li>Note that this should open an alternate port (4489) or your openSUSE server in the cloud.  openSUSE uses 3389 by default, so you need to use an alternate port on the openSUSE server end.</li>
<li>Any connections to the alternate port should be funneled through the SSH tunnel back to the windows 7 PC on port 3389</li>
</ol>
</li>
<li>From a 3rd computer open a remote desktop connection to ssh.host.name:4489
<ol>
<li>Note that remote desktop uses :4489 after the server name to designate an alternate port.</li>
<li>If it acts like you&#8217;re not connecting at all, in all likelihood you&#8217;re not.  You probably have a firewall in place on the openSUSE server.
<ol>
<li>Open port 4489 in your opensuse server firewall
<ol>
<li>https://doc.opensuse.org/documentation/html/openSUSE_122/opensuse-security/cha.security.firewall.html#sec.security.firewall.SuSE.yast</li>
<li>Or   &#8220;sudo /sbin/yast -&gt; security and Users -&gt; Firewall -&gt; Allowed Services -&gt; Advanced -&gt; add 4489 to list of TCP Ports -&gt; OK -&gt; next -&gt; finish -&gt; quit</li>
</ol>
</li>
</ol>
</li>
<li>retry remote desktop connection</li>
</ol>
</li>
<li>Once it works, from the Windows 7 command prompt kill the the ssh connection to your openSUSE server (contrl-C)</li>
</ol>
</li>
<li>Test your AutoSSH Tunnel capability
<ol>
<li>From the CMD prompt running as administrator
<ol>
<li>C:\cygwin\bin\autossh -M 20000 -N -R 4489:localhost:3389 autossh@ssh.host.name
<ol>
<li>Note that-M opens a monitoring port (I&#8217;m not sure how to leverage that)  The monitoring port is opened on the server (ssh.host.name) so if you have multiple autossh commands pointed at the same server, each should use a unique monitoring port as well as a unique tunnel port (4489 in the above.)</li>
</ol>
</li>
</ol>
</li>
<li>From a 3rd computer open a remote desktop connection to ssh.host.name:4489
<ol>
<li>Make sure you terminate your remote desktop session from the 3rd computer when done testing</li>
</ol>
</li>
<li>If it worked, from the Windows 7 command prompt kill the autossh command (contrl-C)</li>
<li>exit out of your cmd window</li>
</ol>
</li>
</ol>
<ul>
<li style="line-height: 1.5">At this point you can manually invoke autossh to setup a semi-persistent tunnel</li>
</ul>
<p>Setup the autossh feature as a Windows service</p>
<p style="padding-left: 30px">Note:</p>
<ul>
<li style="padding-left: 60px">the below uses cygrunsrv to install the Windows service.  If you experience problems cygrunsrv -L, cyrunsrv -LV, and cygrunsrv -R &lt;service&gt;    may all be useful for diagnosing the problem.  The first 2 commands list the installed services, and -R removes installed services.</li>
<li style="padding-left: 60px">Logs for cygrunsrv default to C:\cygwin\var\log\AutoSSH.log</li>
</ul>
<ol>
<li>Install autossh as a Windows service
<ol>
<li>Open a cmd prompt on your target PC as administrator
<ol>
<li>start -&gt; run -&gt; cmd -&gt; right click on &#8220;cmd&#8221; -&gt; left click &#8220;run as administrator&#8221;</li>
</ol>
</li>
<li>cd C:\cygwin\bin</li>
<li>cygrunsrv -I AutoSSH -p /bin/autossh -a &#8220;-M 20000 -N -R 4489:localhost:3389 autossh@ssh.host.name&#8221; -e AUTOSSH_NTSERVICE=yes
<ol>
<li>If you get an error with this command, manually type the &#8221; marks.  They may not be handled properly with cut&amp;paste.</li>
<li>Be very careful with the above.  A misbehaving service can be hard to remove in Windows.  It may require safe mode if the service won&#8217;t accept stop commands.</li>
</ol>
</li>
<li>Tweak Windows service settings.
<ol>
<li>Open the Services management console (Administrative Tools -&gt; Services).</li>
<li>Edit the properties of the AutoSSH service.</li>
<li>In the “Log On” tab, select the “This account” radio button and set the service to run as your current user.  This is very important to do before starting the service in order for the ssh certificate to be used.</li>
<li>Change the startup mode to &#8220;Automatic (Delayed Start)&#8221;</li>
<li>Start the service.</li>
</ol>
</li>
</ol>
</li>
<li>Test your tunnel as described in 6.2 above
<ol>
<li>Be sure to test after rebooting your target Windows 7 or 8.1 PC.</li>
<li>I have had it working for 6months and used it a lot.  I&#8217;ve seen network drops.  Target PC reboots.   openSUSE server reboots.  The tunnel just keeps working.</li>
</ol>
</li>
</ol>
<p>If all went well, congratulations you now have a persistent tunnel</p>
<p style="padding-left: 30px"><span style="text-decoration: underline">You should be aware you have just punched a hole through your firewall, so be sure and consider the security issues associated with that hole.  Many organizations require security beyond a simple login and password when connectivity is provided from outside the firewall.</span></p>
]]></content:encoded>
			</item>
		<item>
		<title>OpenStack Infra/QA Meetup</title>
		<link>https://lizards.opensuse.org/2014/07/23/openstack-infraqa-meetup/</link>
		<pubDate>Wed, 23 Jul 2014 13:54:38 +0000</pubDate>
		<dc:creator><![CDATA[bmwiedemann]]></dc:creator>
				<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[Quality Assurance]]></category>
		<category><![CDATA[cloud]]></category>
		<category><![CDATA[meeting]]></category>
		<category><![CDATA[openstack]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10928</guid>
		<description><![CDATA[Last week, around 30 people from around the world met in Darmstadt, Germany to discuss various things about OpenStack and its automatic testing mechanisms (CI). The meeting was well-organized by Marc Koderer from Deutsche Telekom. We were shown plans of what the Telekom intends to do with virtualization in general and OpenStack in particular and [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Last week, around 30 people from around the world met in Darmstadt, Germany to discuss various things about OpenStack and its automatic testing mechanisms (CI).<br />
The meeting was well-organized by Marc Koderer from Deutsche Telekom.<br />
We were shown plans of what the Telekom intends to do with virtualization in general and OpenStack in particular and the most interesting one to me was to run clouds in dozens of datacenters across Germany, but have a single API for users to access.<br />
There were some introductory sessions about the use of git review and gerrit, that mostly had things I (and I guess the majority of the others) already learned over the years. It included some new parts such as tracking &#8220;specs&#8221; &#8211; specifications (.rst files) in gerrit with proper review by the core reviewers, so that proper processes could already be applied in the design phase to ensure the project is moving in the right direction.</p>
<p>On the second day we learned that the infra team manages servers with puppet, about jenkins-job-builder (jjb) that creates around 4000 jobs from yaml templates. We learned about nodepool that keeps some VMs ready so that jobs in need will not have to wait for them to boot. 180-800 instances is quite an impressive number.<br />
And then we spent three days on discussing and hacking things, the topics and outcomes of which you can find in the etherpad linked from <a href="https://wiki.openstack.org/wiki/Qa_Infra_Meetup_2014">the wiki page</a>.<br />
I got my first infra patch merged, and a SUSE Cloud CI account setup, so that in the future we can test devstack+tempest on openSUSE and have it comment in Gerrit. And maybe some day we can even have a test to deploy crowbar+openstack from git (including the patch from an open review) to provide useful feedback, but for that we might first want to move crowbar (which is consisting of dozens of repos &#8211; one for each module) to <a href="http://ci.openstack.org/stackforge.html">stackforge</a> &#8211; which is the openstack-provided Gerrit hosting.</p>
<p>see also: <a href="http://princessleia.com/journal/?p=9574">pleia2&#8217;s post</a></p>
<p>Overall for me it was a nice experience to work together with all these smart people and we certainly had a lot of fun</p>
]]></content:encoded>
			</item>
		<item>
		<title>And done&#8230;. new images available</title>
		<link>https://lizards.opensuse.org/2014/06/12/and-done-new-images-available/</link>
		<comments>https://lizards.opensuse.org/2014/06/12/and-done-new-images-available/#comments</comments>
		<pubDate>Thu, 12 Jun 2014 22:27:08 +0000</pubDate>
		<dc:creator><![CDATA[rjschwei]]></dc:creator>
				<category><![CDATA[Base System]]></category>
		<category><![CDATA[Distribution]]></category>
		<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[Security]]></category>
		<category><![CDATA[cloud]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10855</guid>
		<description><![CDATA[Hi, It took a bit but I am happy to report that all openSUSE 13.1 images in Amazon EC2, Google Compute Engine and Microsoft Azure public cloud environments have been refreshed. After the latest round of the GNU-TLS and OpenSSL fixes the security was, as usual, extremely efficient in providing fixed packages and these have [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Hi,</p>
<p>It took a bit but I am happy to report that all openSUSE 13.1 images in Amazon EC2, Google Compute Engine and Microsoft Azure public cloud environments have been refreshed. After the latest round of the GNU-TLS and OpenSSL fixes the security was, as usual, extremely efficient in providing fixed packages and these have been available in all cloud images via <i>zypper up</i> since last Friday. As of today the base images available in the public cloud frameworks contain the fixes by default.</p>
<p>In Amazon the new images are as follows:</p>
<ul>
<li>ap-northeast-1:  ami-79296078</li>
<li>ap-southeast-1:  ami-84a7fbd6</li>
<li>ap-southeast-2:  ami-41cbae7b</li>
<li>eu-west-1:  ami-b56aa4c2</li>
<li>sa-east-1:  ami-bffb54a2</li>
<li>us-east-1:  ami-5e708d36</li>
<li>us-west-1:  ami-16f2f553</li>
<li>us-west-2:  ami-b7097487</li>
</ul>
<p>In Google compute engine the image name is: opensuse-13-1-v20140609</p>
<p>The old image (opensuse131-v20140417) has been deprecated. To access the image you will need to add <i>&#8211;image=opensuse-cloud/global/images/opensuse-13-1-v20140609</i> as the openSUSE images are not yet fully integrated into the GCE framework. Still working on that part with Google. This image also has upgrades to the google-cloud-sdk package and enable the <i>bq</i> (big-query) command. The gcloud command is still a bit rough around the edges, but the gcutil command should work as expected. Eventually gcutil is going to be deprecated by Google thus there is work to be done to fix the integration issues with the <i>gcloud</i> command. If anyone has time to work on that please send submit request to the google-cloud-sdk package in the Cloud:Tools project in OBS. Unfortunately Google still hasn&#8217;t posted the source anywhere for open collaboration <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f641.png" alt="&#x1f641;" class="wp-smiley" style="height: 1em; max-height: 1em;" /> . They&#8217;ll get there eventually. I will try and push any changes upstream.</p>
<p>In Azure just search for openSUSE in the Gallery, it&#8217;s more of a point an click thing <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f609.png" alt="&#x1f609;" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p>And that&#8217;s a wrap. Not certain we will be able to improve on the speed of such fire drill updates, but we&#8217;ll try to keep refreshing images as quickly as time allows when critical vulnerabilities in the core libraries get exposed.</p>
<p>Have a lot of fun&#8230;.</p>
]]></content:encoded>
			<wfw:commentRss>https://lizards.opensuse.org/2014/06/12/and-done-new-images-available/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>Have some fun&#8230; patch your kernel</title>
		<link>https://lizards.opensuse.org/2014/05/28/have-some-fun-patch-your-kernel/</link>
		<comments>https://lizards.opensuse.org/2014/05/28/have-some-fun-patch-your-kernel/#comments</comments>
		<pubDate>Wed, 28 May 2014 06:13:37 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[Education]]></category>
		<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Kernel]]></category>
		<category><![CDATA[openSUSE]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10798</guid>
		<description><![CDATA[On this point you should have compiled your own Linux kernel. Get it up and running with your hardware but what&#8217;s the catch with all of this? Why on earth I want to have this much trouble with my operating system when I can write highly popular fiction with DOS and Wordstar? Patching Being this [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>On this <a href="//lizards.opensuse.org/2014/04/15/have-some-fun-today-compile-kernel/" title="Have some fun today… compile kernel">point you should have compiled</a> your own Linux kernel. <a href="//lizards.opensuse.org/2014/04/30/have-some-fun-today-try-your-new-kernel/" title="Have some fun today… try your new kernel">Get it up and running with your hardware</a> but what&#8217;s the catch with all of this? Why on earth I want to have this much trouble with my operating system when I can write <a href="http://www.bbc.com/news/technology-27407502" title="Game of Thrones author George RR Martin: 'Why I still use DOS'">highly popular fiction with DOS and Wordstar</a>?<span id="more-10798"></span></p>
<h2>Patching</h2>
<p>Being this old means that my first OS was MS-DOS (or was it AMIGA or can I count C-64 in?). It was MS-DOS version 3 and it was pain to use but <a href="http://en.wikipedia.org/wiki/4DOS" title="4DOS">4DOS</a> that was something! It had all the goodies that I&#8217;m enjoying in Unix Shell. I also have seen time before rise of Git or Kernel Bitbucket episode. It was those sweet times when Linux kernel was all about patches and there where no broadband connections for homes or 2/3/4/5G wireless Internet.<br />
Patch is small text or binary file that tells what have changed in that particular file. So if two persons are working with same file and they don&#8217;t use version control (which they should use) then they should use patches. I have been long in enough in business and been university life (in specially ICT area) that I know most students tends to send whole changed file and you have to guess what have changed. That annoying and stupid many ways but most of the people argues that it&#8217;s safer to send whole file to make sure all changes are there. So I have to figure out what they have changed and what have I. I know how to  make it but please please all of you should learn it and that end of that rant.<br />
Nowadays most people favor <a href="http://git-scm.com/" title="GIT">GIT</a>, <a href="http://mercurial.selenic.com/" title="Mercurial">Mercurial</a>, <a href="http://subversion.apache.org/" title="Subversion">Subversion</a> or ancient but working <a href="http://en.wikipedia.org/wiki/Concurrent_Versions_System" title="CVS">CVS</a> (Which was de-facto factory standard before Subversion). There is plenty more version control options to choose from but I think those are most popular.<br />
They all work the same way deep down (especially GIT) than sending patch by mail. There just data base of file changes and If you do all of them you get solid file.</p>
<h2>So what all of this means?</h2>
<p>There is still one place where patches are feeling strong and that place is Linux kernel patches. Why to make kernel patch? You want to add new kernel feature but can&#8217;t get it in Linus Torvalds tree? Then you start to deliver it as a patch or patch-set.<br />
There is many healthy patch-sets like openSUSE kernel patch-set if I have to mention one. Feeling utterly confused so it time to read <a href="http://www.linux.org/threads/the-linux-kernel-patches.5301/" title="The Linux Kernel: Patches">this</a> and <a href="https://www.kernel.org/doc/Documentation/applying-patches.txt" title="Applying Patches To The Linux Kernel">this</a> then you should understand little bit more and I can rest my hands for a while from writing.</p>
<h2>Couple of patches BFS and BFQ</h2>
<p>Ok I have wrapped some patches to fit with openSUSE kernel (For you to test with). <a href="http://algo.ing.unimo.it/people/paolo/disk_sched/" title="BFQ">BFQ is Budget Fair Queueing</a> so it&#8217;s more robust than kernel default <a href="https://www.kernel.org/doc/Documentation/block/cfq-iosched.txt" title="CFQ">CFQ</a> . CFQ is tuned for common rotating HDD <a href="http://dev.nuodb.com/techblog/tuning-linux-io-scheduler-ssds" title="NOOP">and it&#8217;s behaving badly with SSDs</a>. BFQ in other words works business as usual with SSD. What are I/O Schedulers? You got to read little bit <a href="http://oreilly.com/catalog/linuxkernel/chapter/ch10.html" title="Understanding the Linux Kernel">here</a> and <a href="http://https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Kernel_Boot_Parameters-The_IO_Scheduler.html" title="4.2. The I/O Scheduler">here</a> to understand about it.<br />
<a href="http://ck-hack.blogspot.fi/" title="BFS">So what is BFS</a>? It&#8217;s more than I/O scheduler it&#8217;s for scheduling task and stuff like that. So both of them makes your desktop fly or they don&#8217;t. They are not part official kernel though both of them want to <a href="http://www.phoronix.com/scan.php?px=MTYyNDU&amp;page=news_item">get in sooner than later</a>.</p>
<h2>Applying patch</h2>
<p>Just download patches to your computer with (and remember they are for Linux kernel version 3.14 [they won&#8217;t work with version 3.something or up coming 3.15 they only work with version 3.14]).</p>
<pre>
wget <a href="https://raw.githubusercontent.com/illuusio/misc-patches/master/linux/opensuse/BFQ/3.14/0001-Budget-Fair-Queueing-I-O-Scheduler.patch">https://raw.githubusercontent.com/illuusio/misc-patches/master/linux/opensuse/BFQ/3.14/0001-Budget-Fair-Queueing-I-O-Scheduler.patch</a>
wget <a href="https://github.com/illuusio/misc-patches/raw/master/linux/opensuse/BFS/3.14/0002-The-Brain-Fuck-Scheduler-v0.447-by-Con-Kolivas.patch" title="0002-The-Brain-Fuck-Scheduler-v0.447-by-Con-Kolivas.patch">https://github.com/illuusio/misc-patches/raw/master/linux/opensuse/BFS/3.14/0002-The-Brain-Fuck-Scheduler-v0.447-by-Con-Kolivas.patch</a></pre>
<p>and apply them again in root where you <a href="//lizards.opensuse.org/2014/04/15/have-some-fun-today-compile-kernel/" title="Have some fun today… compile kernel">cloned git in first part</a></p>
<pre>
patch -p1 -i 0001-Budget-Fair-Queueing-I-O-Scheduler.patch
patch -p1 -i 0002-The-Brain-Fuck-Scheduler-v0.447-by-Con-Kolivas.patch</pre>
<p>and then get config</p>
<pre>
wget <a href="https://raw.githubusercontent.com/illuusio/misc-patches/master/linux/opensuse/config-3.14-bfsbfq" title="config-3.14-bfsbfq">https://raw.githubusercontent.com/illuusio/misc-patches/master/linux/opensuse/config-3.14-bfsbfq</a>
cp config-3.14-bfsbfq .config
make oldconfig</pre>
<p>then compile it <a href="//lizards.opensuse.org/2014/04/30/have-some-fun-today-try-your-new-kernel/" title="Have some fun today… try your new kernel">like last time and get it working</a>. Then you are again on your on in you journey to deeper knowledge.</p>
]]></content:encoded>
			<wfw:commentRss>https://lizards.opensuse.org/2014/05/28/have-some-fun-patch-your-kernel/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>Have some fun today… try your new kernel</title>
		<link>https://lizards.opensuse.org/2014/04/30/have-some-fun-today-try-your-new-kernel/</link>
		<pubDate>Wed, 30 Apr 2014 05:42:44 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[Distribution]]></category>
		<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Kernel]]></category>
		<category><![CDATA[openSUSE]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10740</guid>
		<description><![CDATA[Last blog was about how to compile openSUSE kernel from GIT. Now we see how to get it up and running in your system. Again word of warning: Changing kernel is always bit of a hardcore trick! Even if it comes from trusted and tested binary from openSUSE (sorry I&#8217;m server admin). If you do [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Last blog was about how to <a href="//lizards.opensuse.org/2014/04/15/have-some-fun-today-compile-kernel/" title="Have some fun today… compile kernel">compile openSUSE kernel from GIT</a>. Now we see how to get it up and running in your system. Again word of warning: Changing kernel is always bit of a hardcore trick! Even if it comes from trusted and tested binary from openSUSE (sorry I&#8217;m server admin). <em>If you do it by yourself then you are also on your own if your machine won&#8217;t boot anymore!</em><span id="more-10740"></span></p>
<h2>Basics</h2>
<p>Understanding how Linux boots read about <a href="http://en.wikipedia.org/wiki/Linux_startup_process" title="Linux startup process">Linux startup</a>. Basics are like this: you have file name <a href="http://en.wikipedia.org/wiki/Vmlinux" title="bzImage">bzImage (vmlinuz)</a> that is bzip2 compressed kernel image and then you have Linux kernel modules. You have to understand that everything can be compiled into Linux kernel (ok nearly nowadays) that is why Linux is called <a href="http://stackoverflow.com/questions/4537850/what-is-difference-between-monolithic-and-micro-kernel" title="Monolitich vs Micro">monolithic kernel</a>. Most of the cases that is not how kernel is compiled. You have small boot kernel and then there is plenty of modules besides this bzImage-thing. What are these modules hmm&#8230; it&#8217;s again bit complicated.<br />
Linux Kernel modules are extensions to Linux kernel. They can be new drivers for webcam, new filesystem or they can be bands <a href="https://github.com/usrbinnc/netcat-cpi-kernel-module" title="Cycles Per Instruction ">album like here</a>. Modules are way to get Linux kernel to minimum size and boot ultra fast. After kernel is kicked alive modules are loaded automaticly by user-space tool <a href="http://www.linux.com/news/hardware/peripherals/180950-udev" title="Udev">udev</a>.</p>
<h2>How to get you shiny new Linux kernel working?</h2>
<p>Ok let&#8217;s do it. Never remove your working binary openSUSE RPM kernel or it&#8217;s modules (if you do reinstall them right away back)! If you remove kernel modules it&#8217;s most likely that your machine won&#8217;ẗ boot. Now you know what not to do.. so let&#8217;s see what you can do? You compiled kernel with tutorial that I wrote last time? Then you should have very fancy openSUSE kernel. I assume you are at commandline on same directory where your openSUSE kernel GIT is compiled. Look at directory &#8216;arch/x86_64/boot/&#8217; (or arch/x86/boot/) with </p>
<pre>
ls arch/x86_64/boot/
</pre>
<p>there should be bzImage. Let&#8217;s copy it to correct location (after this only root can do these or with sudo-command) and version number you can get from Makefile current is 3.14.1 (but it changes rapidly so check first three line from Makefile if you are unsure) and suffix &#8216;-desktop&#8217; comes from &#8216;.config&#8217; file.</p>
<pre>
cp arch/x86_64/boot/bzImage /boot/vmlinuz-3.14.1-desktop
cp System.map /boot/System.map-3.14.1-desktop
</pre>
<p>Ok we have kernel in correct place then we have to install modules. Now I have learned in rough way not to use &#8216;make install&#8217; so we do it like this (you can use any temp directory you like I tend to use &#8216;/tmp/kernel-install&#8217;).</p>
<pre>
make INSTALL_MOD_PATH=/tmp/kernel-install modules_install
cd /tmp/kernel-install/lib/modules
cp -r 3.14.1-desktop /lib/modules
</pre>
<p>There is also firmwares but they should be installed by default and remember if you need some outside kernel module they are not build in your new shiny kernel. So if you have some fancy pantsy WIFI or Radeon catalyst you have to compile it afterwards (we see that next time) or you use you searching skills to find out.</p>
<pre>
cd /boot
mkinitrd -k vmlinuz-3.14.1-desktop -i initrd-3.14.1-desktop
grub2-mkconfig &gt; grub2/grub.cfg 
</pre>
<p>And I assume you have grub2. If not don&#8217;t have you have to figure out this by yourself with YaST. GRUB1 config is /boot/grub/menu.lst if you want to do it by hand. Next time you boot it will try to first boot your new kernel you can choose old kernel from start up menu but that is up to you to discover how. If you end up system that is not booting don&#8217;t blame me there is ways to recover but it&#8217;s not this blogs agenda (my kind recommendation to have openSUSE live cd around).</p>
<h2>What is initrd?</h2>
<p>Initrd is for booting. Initrd will be loaded before your harddrive is. There is tools that needed for booting after harddrive is mounted Initrd will step down and kernel start using harddrive. <strong>OBS!</strong> after 13.1 initrd system will be done <a href="https://github.com/openSUSE/kiwi/issues/335" title="Dracut">with new tool</a> not any more with good old mkinitrd.</p>
<p>Ok now you can play with your new Linux Kernel. There can be new tricks or something can be broken. Have again time and patience as long as you have your old kernel and modules you can boot again.</p>
]]></content:encoded>
			</item>
		<item>
		<title>Have some fun today&#8230; compile kernel</title>
		<link>https://lizards.opensuse.org/2014/04/15/have-some-fun-today-compile-kernel/</link>
		<pubDate>Tue, 15 Apr 2014 13:01:31 +0000</pubDate>
		<dc:creator><![CDATA[Tuukka Pasanen]]></dc:creator>
				<category><![CDATA[Distribution]]></category>
		<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[lizards.openSUSE.org]]></category>
		<category><![CDATA[Miscellaneous]]></category>
		<category><![CDATA[Kernel]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10702</guid>
		<description><![CDATA[Are you bored or seeking something to do? Do you want to do something that your friends will call just waste of time but it is so highly nerdy and most cool? Do you want to know what makes openSUSE or Linux in general tick? Kernel? eh what? Imagine a car where you can change [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Are you bored or seeking something to do? Do you want to do something that your friends will call just waste of time but it is so highly nerdy and most cool? Do you want to know what makes openSUSE or Linux in general tick?<span id="more-10702"></span></p>
<h2>Kernel? eh what?</h2>
<p>Imagine a car where you can change motor as many times you like. You can tune your motor as much as you can and you can run it in your car again with Linux you can do that. Your ride with new kernel can be good or really bad (or something between).<br />
As you might know Linux is just a name for Linux-kernel as <a href="http://www.zdnet.com/blog/open-source/linus-torvalds-on-android-the-linux-fork/9426" title="Linus Torvalds on Android, the Linux fork">Google Android is just Google&#8217;s forked Linux kernel</a>. What happens after kernel booting is not that important anymore.</p>
<h2>User-space and kernel-space</h2>
<p>Nearly every modern operating system separate kernel-space and user-space. Your applications like browser works in <a href="http://en.wikipedia.org/wiki/User_space" title="user space">user-space</a> and your USB-stick operates in <a href="http://en.wikipedia.org/wiki/User_space" title="kernel space">kernel-space</a>. In normal life you never have to cross kernel space but If you do you should really find what are: /dev, /proc and /sys directories in Linux. Those directories contains kernel stuff what is in there you have to check from Internet or how /sys works from this <a href="http://en.wikipedia.org/wiki/Sysfs" title="Sysfs">Wikipedia article</a>.</p>
<h2>openSUSE kernel</h2>
<p>Official linux kernel can be found on <a href="https://www.kernel.org/" title="Linux Kernel">https://www.kernel.org/</a> and kernel newbies can go <a href="http://kernelnewbies.org/" title="Linux Kernel Newbies">here</a> (Really give time to that site if you don&#8217;t know what you are doing). You have to make clear to yourself there is no official binaries for Linux kernel. If you compile and start using yours it&#8217;s as official as anyone else. Distributions have their own official kernel binaries and that that.<br />
So you can just pull kernel from git version control down and start compiling right a way. It&#8217;s not that easy you need to have config file and doing that is hardest part. There is preset configs in Linux but I assume you are using openSUSE version of Linux kernel.<br />
That means what you ask from me? You have to understand there is official and only official Linus Torvals kernel <a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git" title="Linus Torvalds git repo">GIT</a> and then there is hundreds versions of kernel that contains some random stuff that is not allowed in mainline Linus Torvalds version.<br />
Mainly every distribution have their own version of Kernel and openSUSE is not an exception of this. openSUSE Linux kernel can be pulled from git: <a href="http://kernel.opensuse.org/cgit/kernel/" title="openSUSE kernel GIT">http://kernel.opensuse.org/cgit/kernel/</a>.</p>
<h2>WTF? ROLF? I&#8217;ll install something that only has binaries</h2>
<p>Yes please do so there is kernel binary running in your openSUSE currently and you don&#8217;t have to change that. Compiling kernel is not for people in hurry nor for people that doesn&#8217;t have adventurous mind or some urge to do it. It takes time to learn and years to master really. In that time frame you just have to admit that sometimes your new compiled kernel doesn&#8217;t event boot. So we start and we need some tools (install them as root)</p>
<pre>
zypper install gcc make git
</pre>
<p>so then we clone openSUSE kernel stable branch (<a href="http://kernel.opensuse.org/git" title="openSUSE kernel Clone">see this page for more</a>)</p>
<pre>
git clone -b stable git://kernel.opensuse.org/kernel.git
</pre>
<p>You need couple of gigabytes free space just for pull and one gigabyte more for the build. So now you have openSUSE Linux kernel. If you like to compile it biw then we get config file. We get that openSUSE uses for desktop kernel from <a href="http://kernel.opensuse.org/cgit/kernel-source/plain/config/x86_64/desktop?h=stable" title="openSUSE kernel config">x86_64</a>. <strong>Attention! if you are using x86 machine it won&#8217;t boot 64-bit kernel! So use this file <a href="http://kernel.opensuse.org/cgit/kernel-source/tree/config/i386/desktop?h=stable" title="openSUSE config for i386">here if you have 32-bit machine</a>.</strong>. After that this is how you do it:</p>
<pre>
wget http://kernel.opensuse.org/cgit/kernel-source/plain/config/x86_64/desktop?h=stable
mv desktop\?h\=stable .config
make oldconfig
make bzImage
make modules
or
make bzImage modules
</pre>
<p>and again it takes time if you have for example 4 cpu you can allways compile with all of them</p>
<pre>
make bzImage modules -j4
</pre>
<p>I won&#8217;t tell you how to get it running until next time. You can tune config with</p>
<pre>
make menuconfig
</pre>
<p>Test compiling with different kernel config options make it non workable and start again. You can test different x86_64/x32 architectures and remove modules or compile everything in kernel (After all linux is monolithic kernel). So happy compiling times and remember to have fun..</p>
]]></content:encoded>
			</item>
		<item>
		<title>Cloudy with a touch of Green</title>
		<link>https://lizards.opensuse.org/2014/03/19/cloudy-with-a-touch-of-green/</link>
		<comments>https://lizards.opensuse.org/2014/03/19/cloudy-with-a-touch-of-green/#comments</comments>
		<pubDate>Wed, 19 Mar 2014 19:08:27 +0000</pubDate>
		<dc:creator><![CDATA[rjschwei]]></dc:creator>
				<category><![CDATA[Distribution]]></category>
		<category><![CDATA[Infrastructure]]></category>
		<category><![CDATA[Packaging]]></category>
		<category><![CDATA[azure]]></category>
		<category><![CDATA[cloud]]></category>
		<category><![CDATA[EC2]]></category>
		<category><![CDATA[gce]]></category>
		<category><![CDATA[openSUSE 13.1]]></category>

		<guid isPermaLink="false">http://lizards.opensuse.org/?p=10678</guid>
		<description><![CDATA[Finally there is some news regarding our public cloud presence and openSUSE 13.1. We now have openSUSE 13.1 images published in Amazon EC2, Google Compute Engine, and Windows Azure. Well, that&#8217;s the announcement, but would make for a rather short blog. Thus, let me talk a bit about how this all works and speculate a [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Finally there is some news regarding our public cloud presence and openSUSE 13.1. We now have openSUSE 13.1 images published in Amazon EC2, Google Compute Engine, and Windows Azure.</p>
<p>Well, that&#8217;s the announcement, but would make for a rather short blog. Thus, let me talk a bit about how this all works and speculate a bit why we&#8217;ve not been all that good with getting stuff out into the public cloud.</p>
<p>Let me start with the speculation part, i.e. hindrances in getting openSUSE images published. In general to get anything into a public cloud one has to have an account. This implies that you hand over your credit card number to the cloud provider and they charge you for the resources you use. Resources in the public cloud are anything and everything that has something to do with data. Compute resources, i.e. the size of an instance w.r.t. memory and number of CPUs are priced differently. Sending data across the network to and from your instances incurs network charges and of course storing stuff in the cloud is not free either. Thus, while anyone can put an image into the cloud and publish it, this service costs the person money, granted not necessarily a lot, but it is a monthly recurring out of pocket expense.</p>
<p>Then there always appears to be the &#8220;official&#8221; apprehension, meaning if person X publishes an openSUSE image from her/his account what makes it &#8220;official&#8221;. Well first we have the problem that the &#8220;official&#8221; stamp is really just an imaginary hurdle. An image that gets published by me is no more or less &#8220;official&#8221; than any other images. I am after all not the release manager or have any of my fingers in the openSUSE release in any way. I do have access to the SUSE accounts and can publish from there and I guess that makes the images &#8220;official&#8221;. But please do not get any ideas about &#8220;official&#8221; images, they do not exist.</p>
<p>Last but not least there is a technical hurdle. Building images in OBS is not necessarily for the faint of heart. Additionally there is a bunch of other stuff that goes along with cloud images. Once you have one it still has to get into the cloud of choice, which requires tools etc.</p>
<p>That&#8217;s enough speculation as to why or why not it may have taken us a bit longer than others, and just for the record we did have openSUSE 12.1 and openSUSE 12.2 images in Amazon. With that lets talk about what is going on.</p>
<p>We have a project in OBS now, actually it has been there for a while, <a href="https://build.opensuse.org/project/show/Cloud:Images" title="Cloud:Images">Cloud:Images</a> that is intended to be used to build openSUSE cloud images. The GCE image that is public and the Amazon image that is public both came from this project. The Azure image that is currently public is one built with SUSE Studio but will at some point also stem from the Cloud:Images OBS project.</p>
<p>Each cloud framework has it&#8217;s own set of tools. The tools are separated into two categories, initialization tools and command line tools. The initialization tools are tools that reside inside the image and these are generally services that interact with the cloud framework. For example <a href="http://cloudinit.readthedocs.org/en/latest/" title="cloud-init">cloud-init</a> is such an initialization tool and it is used in OpenStack images, Amazon images, and Windows Azure images. The command line tools let you interact with the cloud framework to start and stop instances for example. All these tools get built in the <a href="https://build.opensuse.org/project/show/Cloud:Tools" title="Cloud:Tools">Cloud:Tools</a> project in OBS. From there you can install the command line tools into your system and interact with the cloud framework they support. I am also trying to get all these tools into <a href="https://build.opensuse.org/project/show/openSUSE:Factory" title="openSUSE:Factory">openSUSE:Factory</a> to make things a bit easier for image building and cloud interaction come 13.2.</p>
<p>With this lets take a brief closer look at each framework, in alphabetical order no favoritism here.</p>
<p><strong>Amazon EC2</strong></p>
<p>An openSUSE 13.1 image is available in all regions, the AMI (Amazon Machine Image) IDs are as follows:</p>
<p>sa-east-1       =&gt;  ami-2101a23c<br />
ap-northeast-1  =&gt;  ami-bde999bc<br />
ap-southeast-2  =&gt;  ami-b165fc8b<br />
ap-southeast-1  =&gt;  ami-e2e7b6b0<br />
eu-west-1       =&gt;  ami-7110ec06<br />
us-west-1       =&gt;  ami-44ae9101<br />
us-west-2       =&gt;  ami-f0402ec0<br />
us-east-1       =&gt;  ami-ff0e0696</p>
<p>These images use cloud-init as opposed to the &#8220;suse-ami-tools&#8221; that has been used previously and is no longer available in OBS. The cloud-init package is developed in launchpad and was started by the Canonical folks. Unfortunately to contribute you have to sign the Canonical Contributor Agreement (CCA). If you do not want to sign it or cannot sign it for company reasons you can still send stuff to the package and I&#8217;ll try and get the stuff integrated upstream. For the interaction with Amazon we have the <a href="http://aws.amazon.com/cli/" title="aws-cli">aws-cli</a> package. The &#8220;aws&#8221; command line client supersedes all the ec2-*-tools and is an integrated package that can interact with all Amazon services, not just EC2. It is well documented fully open source and hosted on <a href="https://github.com/aws/aws-cli" title="github">github</a>. The aws-cli package replaces the previously maintained ec2-api-tools package which I have removed from OBS.</p>
<p><strong>Google Compute Engine</strong></p>
<p>In GCE things work by name and the openSUSE 13.1 image is named opensuse131-20140227 and is available in all regions. Google images use a number of tools for initialization, google-daemon and google-startup-scripts. All the Google specific tools are in the Cloud:Tools project. Interaction with GCE is handled with two commands, gcutil and gsutil, both provided by the google-cloud-sdk package. As the name suggests google-cloud-sdk has the goal to unify the various Google tools, same basic idea as aws-cli, and Google is working on the unification. Unfortunately they have decided to do this on their own and there is no public project for google-cloud-sdk which makes contributing a bit difficult to say the least. The <a href="https://github.com/GoogleCloudPlatform/gsutil" title="gsutil">gsutil</a> code is hosted on github, thus at least contributing to gsutil is straight forward. Both utilities, gsutil for storage and gcutil for interacting with GCE are well documented.</p>
<p>In GCE we also were able to stand up openSUSE mirrors. These have been integrated into our <a href="https://en.opensuse.org/MirrorBrain" title="mirrorbrain">mirrorbrain</a> infrastructure and are already being used quite heavily. The infrastructure team is taking care of the monitoring and maintenance and that deserves a big THANK YOU from my side. The nice thing about hosting the mirrors in GCE is that when you run an openSUSE instance in GCE you will not have to pay for network charges to pull your updated packages and things are really fast as the update server is located in the same data center as your instance.</p>
<p><strong>Windows Azure</strong></p>
<p>As mentioned previously the current image we have in Azure is based on a build from SUSE Studio. It does not yet contain cloud-init and only has <a href="https://github.com/WindowsAzure/WALinuxAgent" title="WALinuxAgent">WALinuxAgent</a> integrated. This implies that processing of user data is not possible in the image. User data processing requires cloud-init and I just put the finishing touches on cloud-init this week. Anyway, the image in Azure works just fine, and I have no time line when we might replace it with an image that contains cloud-init in addition to WALinuxAgent.</p>
<p>Interacting with Azure is a bit more cumbersome than with the other cloud frameworks. Well, let me qualify this with, if you want packages. The Azure command line tools are implemented using nodejs and are integrated into the <a href="https://www.npmjs.org/" title="npm">npm</a> nodejs package system. Thus, you can use npm to install everything you need. The nodejs implementation provides a bit of a problem in that we hardly have a nodejs infrastructure in the project. I have started packaging the dependencies, but there is a large number and thus this will take a while. Who would ever implement&#8230;.. but that&#8217;s a different topic.</p>
<p>That&#8217;s where we are today. There is plenty of work left to do. For example we should unify the &#8220;generic&#8221; OpenStack image in Cloud:Images with the HP specific one, the HP cloud is based on OpenStack, and also get an openSUSE image published in the HP cloud. There&#8217;s tons of packaging left to do for nodejs modules to support the azure-cli tool. It would be great if we could have openSUSE mirrors in EC2 and Azure to avoid network charges for those using openSUSE images in those clouds. This requires discussions with Amazon and Microsoft, basically we need to be able to run those services for free, which implies that both would become sponsors of our project just like Google has become a sponsor of our project by letting us run the openSUSE mirrors in GCE.</p>
<p>So if you are interested in cloud and public cloud stuff get involved, there is plenty of work and lots of opportunities. If you just want to use the images in the public cloud go ahead, that&#8217;s why they are there. If you want to build on the images we have in OBS and customize them in your own project feel free and use them as you see fit.</p>
]]></content:encoded>
			<wfw:commentRss>https://lizards.opensuse.org/2014/03/19/cloudy-with-a-touch-of-green/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
	</channel>
</rss>
